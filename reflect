#include <source_location>
#include <string_view>

namespace detail {
template <class T>
extern const T external;
struct any_type {
    template <class T>
    constexpr operator T();
};
template <class TPtr>
struct ptr {
    const TPtr* ptr;
};

template <auto N, class T>
[[nodiscard]] constexpr auto nth_ptr(T&& t) {
    if constexpr (requires { T{any_type{}, any_type{}, any_type{}}; }) {
        auto&& [p1, p2, p3] = t;
        if constexpr (N == 0) return ptr<decltype(p1)>{&p1};
        if constexpr (N == 1) return ptr<decltype(p2)>{&p2};
        if constexpr (N == 2) return ptr<decltype(p3)>{&p3};
    } else if constexpr (requires { T{any_type{}, any_type{}}; }) {
        auto&& [p1, p2] = t;
        if constexpr (N == 0) return ptr<decltype(p1)>{&p1};
        if constexpr (N == 1) return ptr<decltype(p2)>{&p2};
    } else if constexpr (requires { T{any_type{}}; }) {
        auto&& [p1] = t;
        if constexpr (N == 0) return ptr<decltype(p1)>{&p1};
    }
}

template <auto Ptr>
[[nodiscard]] consteval auto get_name() -> std::string_view {
    return std::source_location::current().function_name();
}

template <auto N, class T>
constexpr auto get_name_impl =
    detail::get_name<detail::nth_ptr<N>(detail::external<T>)>();

struct $struct$ { int $field$; };
constexpr auto $name = get_name_impl<0, detail::$struct$>;
constexpr auto $end = $name.substr($name.find("$field$")+sizeof("$field$")-1);
constexpr auto $begin = $name[$name.find("$field$")-1];
}  // namespace detail

template <auto N, class T>
constexpr auto get_name = [] { 
    const auto name = detail::get_name_impl<N, T>;
    const auto begin = name.find(detail::$end);
    const auto tmp = name.substr(0, begin);
    return tmp.substr(tmp.find_last_of(detail::$begin)+1);
}();

struct foo {
    int bar;
    int baz;
};

using namespace std::literals::string_view_literals;

static_assert("bar"sv == get_name<0, foo>);
static_assert("baz"sv == get_name<1, foo>);
