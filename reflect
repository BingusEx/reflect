//
// Copyright (c) 2024 Kris Jusiak (kris at jusiak dot net)
//
// Distributed under the Boost Software License, Version 1.0.
// (See accompanying file LICENSE_1_0.txt or copy at
// http://www.boost.org/LICENSE_1_0.txt)
//
#ifndef REFLECT
#define REFLECT 1'0'0 // SemVer - should match reflect namespace

#if not defined(REFLECT_MAX_SIZE)
#define REFLECT_MAX_SIZE 64 // requires len(overloads reflect::detail::visit) >= REFLECT_MAX_SIZE
#endif

#if not defined(REFLECT_ENUM_MIN)
#define REFLECT_ENUM_MIN 0
#endif

#if not defined(REFLECT_ENUM_MAX)
#define REFLECT_ENUM_MAX 64
#endif

#include <algorithm>
#include <array>
#include <string_view>
#include <source_location>
#include <type_traits>
#include <tuple>

struct reflect_STRUCT { reflect_STRUCT* MEMBER; enum class ENUM { VALUE }; }; // has to be in the global namespace

/**
 * Minimal static reflection library
 */
namespace reflect::inline v1_0_0 {
namespace detail {
template <class T> extern const T ext{};
struct any { template <class T> operator T(); };
template <class T> struct ptr { const T* value; };
template <class T> ptr(const T*) -> ptr<T>;
template<std::size_t N> struct tag : tag<N-1> { };
template<> struct tag<0> { };
template<std::size_t N> [[nodiscard]] constexpr decltype(auto) nth_pack_element(auto&&... args) noexcept {
  return [&]<auto... Ns>(std::index_sequence<Ns...>) -> decltype(auto) {
    return [](decltype((const void*)Ns)..., auto* nth, auto*...) -> decltype(auto) { return *nth; }(&args...);
  }(std::make_index_sequence<N>{});
}

static_assert(1 == nth_pack_element<0>(1));
static_assert(1 == nth_pack_element<0>(1, 2));
static_assert(2 == nth_pack_element<1>(1, 2));
static_assert('a' == nth_pack_element<0>('a', 1, true));
static_assert(1 == nth_pack_element<1>('a', 1, true));
static_assert(true == nth_pack_element<2>('a', 1, true));

template<auto  V> [[nodiscard]] consteval auto function_name() noexcept -> std::string_view { return std::source_location::current().function_name(); }
template<class T> [[nodiscard]] consteval auto function_name() noexcept -> std::string_view { return std::source_location::current().function_name(); }

struct type_name_info {
  static constexpr auto name = function_name<reflect_STRUCT>();
  static constexpr auto begin = name.find("reflect_STRUCT");
  static constexpr auto end = name.substr(begin+std::size(std::string_view{"reflect_STRUCT"}));
};

struct enum_name_info {
  static constexpr auto name = function_name<reflect_STRUCT::ENUM::VALUE>();
  static constexpr auto begin = name[name.find("reflect_STRUCT::ENUM::VALUE")-1];
  static constexpr auto end = name.substr(name.find("reflect_STRUCT::ENUM::VALUE")+std::size(std::string_view{"reflect_STRUCT::ENUM::VALUE"}));
};

struct member_name_info {
  static constexpr auto name = function_name<ptr{&ext<reflect_STRUCT>.MEMBER}>();
  static constexpr auto begin = name[name.find("MEMBER")-1];
  static constexpr auto end = name.substr(name.find("MEMBER")+std::size(std::string_view{"MEMBER"}));
};

template <class Fn, class T>
  requires requires { std::remove_cvref_t<T>{}; }
[[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&&, tag<0>) noexcept {
  return std::forward<Fn>(fn)();
}

template <class Fn, class T>
  requires requires { std::remove_cvref_t<T>{any{}}; }
[[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, tag<1>) noexcept {
  auto&& [_1] = std::forward<T>(t);
  return std::forward<Fn>(fn)(std::forward<decltype(_1)>(_1));
}

template <class Fn, class T>
  requires requires { std::remove_cvref_t<T>{any{}, any{}}; }
[[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, tag<2>) noexcept {
  auto&& [_1, _2] = std::forward<T>(t);
  return std::forward<Fn>(fn)(std::forward<decltype(_1)>(_1), std::forward<decltype(_2)>(_2));
}

template <class Fn, class T>
  requires requires { std::remove_cvref_t<T>{any{}, any{}, any{}}; }
[[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, tag<3>) noexcept {
  auto&& [_1, _2, _3] = std::forward<T>(t);
  return std::forward<Fn>(fn)(std::forward<decltype(_1)>(_1), std::forward<decltype(_2)>(_2), std::forward<decltype(_3)>(_3));
}

template <class Fn, class T>
  requires requires { std::remove_cvref_t<T>{any{}, any{}, any{}, any{}}; }
[[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, tag<4>) noexcept {
  auto&& [_1, _2, _3, _4] = std::forward<T>(t);
  return std::forward<Fn>(fn)(std::forward<decltype(_1)>(_1), std::forward<decltype(_2)>(_2), std::forward<decltype(_3)>(_3), std::forward<decltype(_4)>(_4));
}

template <class Fn, class T>
  requires requires { std::remove_cvref_t<T>{any{}, any{}, any{}, any{}, any{}}; }
[[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, tag<5>) noexcept {
  auto&& [_1, _2, _3, _4, _5] = std::forward<T>(t);
  return std::forward<Fn>(fn)(std::forward<decltype(_1)>(_1), std::forward<decltype(_2)>(_2), std::forward<decltype(_3)>(_3), std::forward<decltype(_4)>(_4), std::forward<decltype(_5)>(_5));
}

template <class Fn, class T>
  requires requires { std::remove_cvref_t<T>{any{}, any{}, any{}, any{}, any{}, any{}}; }
[[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, tag<6>) noexcept {
  auto&& [_1, _2, _3, _4, _5, _6] = std::forward<T>(t);
  return std::forward<Fn>(fn)(std::forward<decltype(_1)>(_1), std::forward<decltype(_2)>(_2), std::forward<decltype(_3)>(_3), std::forward<decltype(_4)>(_4), std::forward<decltype(_5)>(_5), std::forward<decltype(_6)>(_6));
}

template <class Fn, class T>
  requires requires { std::remove_cvref_t<T>{any{}, any{}, any{}, any{}, any{}, any{}, any{}}; }
[[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, tag<7>) noexcept {
  auto&& [_1, _2, _3, _4, _5, _6, _7] = std::forward<T>(t);
  return std::forward<Fn>(fn)(std::forward<decltype(_1)>(_1), std::forward<decltype(_2)>(_2), std::forward<decltype(_3)>(_3), std::forward<decltype(_4)>(_4), std::forward<decltype(_5)>(_5), std::forward<decltype(_6)>(_6), std::forward<decltype(_7)>(_7));
}

template <class Fn, class T>
  requires requires { std::remove_cvref_t<T>{any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}}; }
[[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, tag<8>) noexcept {
  auto&& [_1, _2, _3, _4, _5, _6, _7, _8] = std::forward<T>(t);
  return std::forward<Fn>(fn)(std::forward<decltype(_1)>(_1), std::forward<decltype(_2)>(_2), std::forward<decltype(_3)>(_3), std::forward<decltype(_4)>(_4), std::forward<decltype(_5)>(_5), std::forward<decltype(_6)>(_6), std::forward<decltype(_7)>(_7), std::forward<decltype(_8)>(_8));
}

template <class Fn, class T>
  requires requires { std::remove_cvref_t<T>{any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}}; }
[[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, tag<9>) noexcept {
  auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9] = std::forward<T>(t);
  return std::forward<Fn>(fn)(std::forward<decltype(_1)>(_1), std::forward<decltype(_2)>(_2), std::forward<decltype(_3)>(_3), std::forward<decltype(_4)>(_4), std::forward<decltype(_5)>(_5), std::forward<decltype(_6)>(_6), std::forward<decltype(_7)>(_7), std::forward<decltype(_8)>(_8), std::forward<decltype(_9)>(_9));
}

template <class Fn, class T>
  requires requires { std::remove_cvref_t<T>{any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}}; }
[[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, tag<10>) noexcept {
  auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10] = std::forward<T>(t);
  return std::forward<Fn>(fn)(std::forward<decltype(_1)>(_1), std::forward<decltype(_2)>(_2), std::forward<decltype(_3)>(_3), std::forward<decltype(_4)>(_4), std::forward<decltype(_5)>(_5), std::forward<decltype(_6)>(_6), std::forward<decltype(_7)>(_7), std::forward<decltype(_8)>(_8), std::forward<decltype(_9)>(_9), std::forward<decltype(_10)>(_10));
}

template <class Fn, class T>
  requires requires { std::remove_cvref_t<T>{any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}}; }
[[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, tag<11>) noexcept {
  auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11] = std::forward<T>(t);
  return std::forward<Fn>(fn)(std::forward<decltype(_1)>(_1), std::forward<decltype(_2)>(_2), std::forward<decltype(_3)>(_3), std::forward<decltype(_4)>(_4), std::forward<decltype(_5)>(_5), std::forward<decltype(_6)>(_6), std::forward<decltype(_7)>(_7), std::forward<decltype(_8)>(_8), std::forward<decltype(_9)>(_9), std::forward<decltype(_10)>(_10), std::forward<decltype(_11)>(_11));
}

template <class Fn, class T>
  requires requires { std::remove_cvref_t<T>{any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}}; }
[[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, tag<12>) noexcept {
  auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12] = std::forward<T>(t);
  return std::forward<Fn>(fn)(std::forward<decltype(_1)>(_1), std::forward<decltype(_2)>(_2), std::forward<decltype(_3)>(_3), std::forward<decltype(_4)>(_4), std::forward<decltype(_5)>(_5), std::forward<decltype(_6)>(_6), std::forward<decltype(_7)>(_7), std::forward<decltype(_8)>(_8), std::forward<decltype(_9)>(_9), std::forward<decltype(_10)>(_10), std::forward<decltype(_11)>(_11), std::forward<decltype(_12)>(_12));
}

template <class Fn, class T>
  requires requires { std::remove_cvref_t<T>{any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}}; }
[[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, tag<13>) noexcept {
  auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13] = std::forward<T>(t);
  return std::forward<Fn>(fn)(std::forward<decltype(_1)>(_1), std::forward<decltype(_2)>(_2), std::forward<decltype(_3)>(_3), std::forward<decltype(_4)>(_4), std::forward<decltype(_5)>(_5), std::forward<decltype(_6)>(_6), std::forward<decltype(_7)>(_7), std::forward<decltype(_8)>(_8), std::forward<decltype(_9)>(_9), std::forward<decltype(_10)>(_10), std::forward<decltype(_11)>(_11), std::forward<decltype(_12)>(_12), std::forward<decltype(_13)>(_13));
}

template <class Fn, class T>
  requires requires { std::remove_cvref_t<T>{any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}}; }
[[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, tag<14>) noexcept {
  auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14] = std::forward<T>(t);
  return std::forward<Fn>(fn)(std::forward<decltype(_1)>(_1), std::forward<decltype(_2)>(_2), std::forward<decltype(_3)>(_3), std::forward<decltype(_4)>(_4), std::forward<decltype(_5)>(_5), std::forward<decltype(_6)>(_6), std::forward<decltype(_7)>(_7), std::forward<decltype(_8)>(_8), std::forward<decltype(_9)>(_9), std::forward<decltype(_10)>(_10), std::forward<decltype(_11)>(_11), std::forward<decltype(_12)>(_12), std::forward<decltype(_13)>(_13), std::forward<decltype(_14)>(_14));
}

template <class Fn, class T>
  requires requires { std::remove_cvref_t<T>{any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}}; }
[[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, tag<15>) noexcept {
  auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15] = std::forward<T>(t);
  return std::forward<Fn>(fn)(std::forward<decltype(_1)>(_1), std::forward<decltype(_2)>(_2), std::forward<decltype(_3)>(_3), std::forward<decltype(_4)>(_4), std::forward<decltype(_5)>(_5), std::forward<decltype(_6)>(_6), std::forward<decltype(_7)>(_7), std::forward<decltype(_8)>(_8), std::forward<decltype(_9)>(_9), std::forward<decltype(_10)>(_10), std::forward<decltype(_11)>(_11), std::forward<decltype(_12)>(_12), std::forward<decltype(_13)>(_13), std::forward<decltype(_14)>(_14), std::forward<decltype(_15)>(_15));
}

template <class Fn, class T>
  requires requires { std::remove_cvref_t<T>{any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}}; }
[[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, tag<16>) noexcept {
  auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16] = std::forward<T>(t);
  return std::forward<Fn>(fn)(std::forward<decltype(_1)>(_1), std::forward<decltype(_2)>(_2), std::forward<decltype(_3)>(_3), std::forward<decltype(_4)>(_4), std::forward<decltype(_5)>(_5), std::forward<decltype(_6)>(_6), std::forward<decltype(_7)>(_7), std::forward<decltype(_8)>(_8), std::forward<decltype(_9)>(_9), std::forward<decltype(_10)>(_10), std::forward<decltype(_11)>(_11), std::forward<decltype(_12)>(_12), std::forward<decltype(_13)>(_13), std::forward<decltype(_14)>(_14), std::forward<decltype(_15)>(_15), std::forward<decltype(_16)>(_16));
}

template <class Fn, class T>
  requires requires { std::remove_cvref_t<T>{any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}}; }
[[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, tag<17>) noexcept {
  auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17] = std::forward<T>(t);
  return std::forward<Fn>(fn)(std::forward<decltype(_1)>(_1), std::forward<decltype(_2)>(_2), std::forward<decltype(_3)>(_3), std::forward<decltype(_4)>(_4), std::forward<decltype(_5)>(_5), std::forward<decltype(_6)>(_6), std::forward<decltype(_7)>(_7), std::forward<decltype(_8)>(_8), std::forward<decltype(_9)>(_9), std::forward<decltype(_10)>(_10), std::forward<decltype(_11)>(_11), std::forward<decltype(_12)>(_12), std::forward<decltype(_13)>(_13), std::forward<decltype(_14)>(_14), std::forward<decltype(_15)>(_15), std::forward<decltype(_16)>(_16), std::forward<decltype(_17)>(_17));
}

template <class Fn, class T>
  requires requires { std::remove_cvref_t<T>{any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}}; }
[[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, tag<18>) noexcept {
  auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18] = std::forward<T>(t);
  return std::forward<Fn>(fn)(std::forward<decltype(_1)>(_1), std::forward<decltype(_2)>(_2), std::forward<decltype(_3)>(_3), std::forward<decltype(_4)>(_4), std::forward<decltype(_5)>(_5), std::forward<decltype(_6)>(_6), std::forward<decltype(_7)>(_7), std::forward<decltype(_8)>(_8), std::forward<decltype(_9)>(_9), std::forward<decltype(_10)>(_10), std::forward<decltype(_11)>(_11), std::forward<decltype(_12)>(_12), std::forward<decltype(_13)>(_13), std::forward<decltype(_14)>(_14), std::forward<decltype(_15)>(_15), std::forward<decltype(_16)>(_16), std::forward<decltype(_17)>(_17), std::forward<decltype(_18)>(_18));
}

template <class Fn, class T>
  requires requires { std::remove_cvref_t<T>{any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}}; }
[[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, tag<19>) noexcept {
  auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19] = std::forward<T>(t);
  return std::forward<Fn>(fn)(std::forward<decltype(_1)>(_1), std::forward<decltype(_2)>(_2), std::forward<decltype(_3)>(_3), std::forward<decltype(_4)>(_4), std::forward<decltype(_5)>(_5), std::forward<decltype(_6)>(_6), std::forward<decltype(_7)>(_7), std::forward<decltype(_8)>(_8), std::forward<decltype(_9)>(_9), std::forward<decltype(_10)>(_10), std::forward<decltype(_11)>(_11), std::forward<decltype(_12)>(_12), std::forward<decltype(_13)>(_13), std::forward<decltype(_14)>(_14), std::forward<decltype(_15)>(_15), std::forward<decltype(_16)>(_16), std::forward<decltype(_17)>(_17), std::forward<decltype(_18)>(_18), std::forward<decltype(_19)>(_19));
}

template <class Fn, class T>
  requires requires { std::remove_cvref_t<T>{any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}}; }
[[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, tag<20>) noexcept {
  auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20] = std::forward<T>(t);
  return std::forward<Fn>(fn)(std::forward<decltype(_1)>(_1), std::forward<decltype(_2)>(_2), std::forward<decltype(_3)>(_3), std::forward<decltype(_4)>(_4), std::forward<decltype(_5)>(_5), std::forward<decltype(_6)>(_6), std::forward<decltype(_7)>(_7), std::forward<decltype(_8)>(_8), std::forward<decltype(_9)>(_9), std::forward<decltype(_10)>(_10), std::forward<decltype(_11)>(_11), std::forward<decltype(_12)>(_12), std::forward<decltype(_13)>(_13), std::forward<decltype(_14)>(_14), std::forward<decltype(_15)>(_15), std::forward<decltype(_16)>(_16), std::forward<decltype(_17)>(_17), std::forward<decltype(_18)>(_18), std::forward<decltype(_19)>(_19), std::forward<decltype(_20)>(_20));
}

template <class Fn, class T>
  requires requires { std::remove_cvref_t<T>{any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}}; }
[[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, tag<21>) noexcept {
  auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21] = std::forward<T>(t);
  return std::forward<Fn>(fn)(std::forward<decltype(_1)>(_1), std::forward<decltype(_2)>(_2), std::forward<decltype(_3)>(_3), std::forward<decltype(_4)>(_4), std::forward<decltype(_5)>(_5), std::forward<decltype(_6)>(_6), std::forward<decltype(_7)>(_7), std::forward<decltype(_8)>(_8), std::forward<decltype(_9)>(_9), std::forward<decltype(_10)>(_10), std::forward<decltype(_11)>(_11), std::forward<decltype(_12)>(_12), std::forward<decltype(_13)>(_13), std::forward<decltype(_14)>(_14), std::forward<decltype(_15)>(_15), std::forward<decltype(_16)>(_16), std::forward<decltype(_17)>(_17), std::forward<decltype(_18)>(_18), std::forward<decltype(_19)>(_19), std::forward<decltype(_20)>(_20), std::forward<decltype(_21)>(_21));
}

template <class Fn, class T>
  requires requires { std::remove_cvref_t<T>{any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}}; }
[[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, tag<22>) noexcept {
  auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22] = std::forward<T>(t);
  return std::forward<Fn>(fn)(std::forward<decltype(_1)>(_1), std::forward<decltype(_2)>(_2), std::forward<decltype(_3)>(_3), std::forward<decltype(_4)>(_4), std::forward<decltype(_5)>(_5), std::forward<decltype(_6)>(_6), std::forward<decltype(_7)>(_7), std::forward<decltype(_8)>(_8), std::forward<decltype(_9)>(_9), std::forward<decltype(_10)>(_10), std::forward<decltype(_11)>(_11), std::forward<decltype(_12)>(_12), std::forward<decltype(_13)>(_13), std::forward<decltype(_14)>(_14), std::forward<decltype(_15)>(_15), std::forward<decltype(_16)>(_16), std::forward<decltype(_17)>(_17), std::forward<decltype(_18)>(_18), std::forward<decltype(_19)>(_19), std::forward<decltype(_20)>(_20), std::forward<decltype(_21)>(_21), std::forward<decltype(_22)>(_22));
}

template <class Fn, class T>
  requires requires { std::remove_cvref_t<T>{any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}}; }
[[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, tag<23>) noexcept {
  auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23] = std::forward<T>(t);
  return std::forward<Fn>(fn)(std::forward<decltype(_1)>(_1), std::forward<decltype(_2)>(_2), std::forward<decltype(_3)>(_3), std::forward<decltype(_4)>(_4), std::forward<decltype(_5)>(_5), std::forward<decltype(_6)>(_6), std::forward<decltype(_7)>(_7), std::forward<decltype(_8)>(_8), std::forward<decltype(_9)>(_9), std::forward<decltype(_10)>(_10), std::forward<decltype(_11)>(_11), std::forward<decltype(_12)>(_12), std::forward<decltype(_13)>(_13), std::forward<decltype(_14)>(_14), std::forward<decltype(_15)>(_15), std::forward<decltype(_16)>(_16), std::forward<decltype(_17)>(_17), std::forward<decltype(_18)>(_18), std::forward<decltype(_19)>(_19), std::forward<decltype(_20)>(_20), std::forward<decltype(_21)>(_21), std::forward<decltype(_22)>(_22), std::forward<decltype(_23)>(_23));
}

template <class Fn, class T>
  requires requires { std::remove_cvref_t<T>{any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}}; }
[[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, tag<24>) noexcept {
  auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24] = std::forward<T>(t);
  return std::forward<Fn>(fn)(std::forward<decltype(_1)>(_1), std::forward<decltype(_2)>(_2), std::forward<decltype(_3)>(_3), std::forward<decltype(_4)>(_4), std::forward<decltype(_5)>(_5), std::forward<decltype(_6)>(_6), std::forward<decltype(_7)>(_7), std::forward<decltype(_8)>(_8), std::forward<decltype(_9)>(_9), std::forward<decltype(_10)>(_10), std::forward<decltype(_11)>(_11), std::forward<decltype(_12)>(_12), std::forward<decltype(_13)>(_13), std::forward<decltype(_14)>(_14), std::forward<decltype(_15)>(_15), std::forward<decltype(_16)>(_16), std::forward<decltype(_17)>(_17), std::forward<decltype(_18)>(_18), std::forward<decltype(_19)>(_19), std::forward<decltype(_20)>(_20), std::forward<decltype(_21)>(_21), std::forward<decltype(_22)>(_22), std::forward<decltype(_23)>(_23), std::forward<decltype(_24)>(_24));
}

template <class Fn, class T>
  requires requires { std::remove_cvref_t<T>{any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}}; }
[[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, tag<25>) noexcept {
  auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25] = std::forward<T>(t);
  return std::forward<Fn>(fn)(std::forward<decltype(_1)>(_1), std::forward<decltype(_2)>(_2), std::forward<decltype(_3)>(_3), std::forward<decltype(_4)>(_4), std::forward<decltype(_5)>(_5), std::forward<decltype(_6)>(_6), std::forward<decltype(_7)>(_7), std::forward<decltype(_8)>(_8), std::forward<decltype(_9)>(_9), std::forward<decltype(_10)>(_10), std::forward<decltype(_11)>(_11), std::forward<decltype(_12)>(_12), std::forward<decltype(_13)>(_13), std::forward<decltype(_14)>(_14), std::forward<decltype(_15)>(_15), std::forward<decltype(_16)>(_16), std::forward<decltype(_17)>(_17), std::forward<decltype(_18)>(_18), std::forward<decltype(_19)>(_19), std::forward<decltype(_20)>(_20), std::forward<decltype(_21)>(_21), std::forward<decltype(_22)>(_22), std::forward<decltype(_23)>(_23), std::forward<decltype(_24)>(_24), std::forward<decltype(_25)>(_25));
}

template <class Fn, class T>
  requires requires { std::remove_cvref_t<T>{any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}}; }
[[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, tag<26>) noexcept {
  auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26] = std::forward<T>(t);
  return std::forward<Fn>(fn)(std::forward<decltype(_1)>(_1), std::forward<decltype(_2)>(_2), std::forward<decltype(_3)>(_3), std::forward<decltype(_4)>(_4), std::forward<decltype(_5)>(_5), std::forward<decltype(_6)>(_6), std::forward<decltype(_7)>(_7), std::forward<decltype(_8)>(_8), std::forward<decltype(_9)>(_9), std::forward<decltype(_10)>(_10), std::forward<decltype(_11)>(_11), std::forward<decltype(_12)>(_12), std::forward<decltype(_13)>(_13), std::forward<decltype(_14)>(_14), std::forward<decltype(_15)>(_15), std::forward<decltype(_16)>(_16), std::forward<decltype(_17)>(_17), std::forward<decltype(_18)>(_18), std::forward<decltype(_19)>(_19), std::forward<decltype(_20)>(_20), std::forward<decltype(_21)>(_21), std::forward<decltype(_22)>(_22), std::forward<decltype(_23)>(_23), std::forward<decltype(_24)>(_24), std::forward<decltype(_25)>(_25), std::forward<decltype(_26)>(_26));
}

template <class Fn, class T>
  requires requires { std::remove_cvref_t<T>{any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}}; }
[[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, tag<27>) noexcept {
  auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27] = std::forward<T>(t);
  return std::forward<Fn>(fn)(std::forward<decltype(_1)>(_1), std::forward<decltype(_2)>(_2), std::forward<decltype(_3)>(_3), std::forward<decltype(_4)>(_4), std::forward<decltype(_5)>(_5), std::forward<decltype(_6)>(_6), std::forward<decltype(_7)>(_7), std::forward<decltype(_8)>(_8), std::forward<decltype(_9)>(_9), std::forward<decltype(_10)>(_10), std::forward<decltype(_11)>(_11), std::forward<decltype(_12)>(_12), std::forward<decltype(_13)>(_13), std::forward<decltype(_14)>(_14), std::forward<decltype(_15)>(_15), std::forward<decltype(_16)>(_16), std::forward<decltype(_17)>(_17), std::forward<decltype(_18)>(_18), std::forward<decltype(_19)>(_19), std::forward<decltype(_20)>(_20), std::forward<decltype(_21)>(_21), std::forward<decltype(_22)>(_22), std::forward<decltype(_23)>(_23), std::forward<decltype(_24)>(_24), std::forward<decltype(_25)>(_25), std::forward<decltype(_26)>(_26), std::forward<decltype(_27)>(_27));
}

template <class Fn, class T>
  requires requires { std::remove_cvref_t<T>{any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}}; }
[[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, tag<28>) noexcept {
  auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28] = std::forward<T>(t);
  return std::forward<Fn>(fn)(std::forward<decltype(_1)>(_1), std::forward<decltype(_2)>(_2), std::forward<decltype(_3)>(_3), std::forward<decltype(_4)>(_4), std::forward<decltype(_5)>(_5), std::forward<decltype(_6)>(_6), std::forward<decltype(_7)>(_7), std::forward<decltype(_8)>(_8), std::forward<decltype(_9)>(_9), std::forward<decltype(_10)>(_10), std::forward<decltype(_11)>(_11), std::forward<decltype(_12)>(_12), std::forward<decltype(_13)>(_13), std::forward<decltype(_14)>(_14), std::forward<decltype(_15)>(_15), std::forward<decltype(_16)>(_16), std::forward<decltype(_17)>(_17), std::forward<decltype(_18)>(_18), std::forward<decltype(_19)>(_19), std::forward<decltype(_20)>(_20), std::forward<decltype(_21)>(_21), std::forward<decltype(_22)>(_22), std::forward<decltype(_23)>(_23), std::forward<decltype(_24)>(_24), std::forward<decltype(_25)>(_25), std::forward<decltype(_26)>(_26), std::forward<decltype(_27)>(_27), std::forward<decltype(_28)>(_28));
}

template <class Fn, class T>
  requires requires { std::remove_cvref_t<T>{any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}}; }
[[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, tag<29>) noexcept {
  auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29] = std::forward<T>(t);
  return std::forward<Fn>(fn)(std::forward<decltype(_1)>(_1), std::forward<decltype(_2)>(_2), std::forward<decltype(_3)>(_3), std::forward<decltype(_4)>(_4), std::forward<decltype(_5)>(_5), std::forward<decltype(_6)>(_6), std::forward<decltype(_7)>(_7), std::forward<decltype(_8)>(_8), std::forward<decltype(_9)>(_9), std::forward<decltype(_10)>(_10), std::forward<decltype(_11)>(_11), std::forward<decltype(_12)>(_12), std::forward<decltype(_13)>(_13), std::forward<decltype(_14)>(_14), std::forward<decltype(_15)>(_15), std::forward<decltype(_16)>(_16), std::forward<decltype(_17)>(_17), std::forward<decltype(_18)>(_18), std::forward<decltype(_19)>(_19), std::forward<decltype(_20)>(_20), std::forward<decltype(_21)>(_21), std::forward<decltype(_22)>(_22), std::forward<decltype(_23)>(_23), std::forward<decltype(_24)>(_24), std::forward<decltype(_25)>(_25), std::forward<decltype(_26)>(_26), std::forward<decltype(_27)>(_27), std::forward<decltype(_28)>(_28), std::forward<decltype(_29)>(_29));
}

template <class Fn, class T>
  requires requires { std::remove_cvref_t<T>{any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}}; }
[[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, tag<30>) noexcept {
  auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30] = std::forward<T>(t);
  return std::forward<Fn>(fn)(std::forward<decltype(_1)>(_1), std::forward<decltype(_2)>(_2), std::forward<decltype(_3)>(_3), std::forward<decltype(_4)>(_4), std::forward<decltype(_5)>(_5), std::forward<decltype(_6)>(_6), std::forward<decltype(_7)>(_7), std::forward<decltype(_8)>(_8), std::forward<decltype(_9)>(_9), std::forward<decltype(_10)>(_10), std::forward<decltype(_11)>(_11), std::forward<decltype(_12)>(_12), std::forward<decltype(_13)>(_13), std::forward<decltype(_14)>(_14), std::forward<decltype(_15)>(_15), std::forward<decltype(_16)>(_16), std::forward<decltype(_17)>(_17), std::forward<decltype(_18)>(_18), std::forward<decltype(_19)>(_19), std::forward<decltype(_20)>(_20), std::forward<decltype(_21)>(_21), std::forward<decltype(_22)>(_22), std::forward<decltype(_23)>(_23), std::forward<decltype(_24)>(_24), std::forward<decltype(_25)>(_25), std::forward<decltype(_26)>(_26), std::forward<decltype(_27)>(_27), std::forward<decltype(_28)>(_28), std::forward<decltype(_29)>(_29), std::forward<decltype(_30)>(_30));
}

template <class Fn, class T>
  requires requires { std::remove_cvref_t<T>{any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}}; }
[[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, tag<31>) noexcept {
  auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31] = std::forward<T>(t);
  return std::forward<Fn>(fn)(std::forward<decltype(_1)>(_1), std::forward<decltype(_2)>(_2), std::forward<decltype(_3)>(_3), std::forward<decltype(_4)>(_4), std::forward<decltype(_5)>(_5), std::forward<decltype(_6)>(_6), std::forward<decltype(_7)>(_7), std::forward<decltype(_8)>(_8), std::forward<decltype(_9)>(_9), std::forward<decltype(_10)>(_10), std::forward<decltype(_11)>(_11), std::forward<decltype(_12)>(_12), std::forward<decltype(_13)>(_13), std::forward<decltype(_14)>(_14), std::forward<decltype(_15)>(_15), std::forward<decltype(_16)>(_16), std::forward<decltype(_17)>(_17), std::forward<decltype(_18)>(_18), std::forward<decltype(_19)>(_19), std::forward<decltype(_20)>(_20), std::forward<decltype(_21)>(_21), std::forward<decltype(_22)>(_22), std::forward<decltype(_23)>(_23), std::forward<decltype(_24)>(_24), std::forward<decltype(_25)>(_25), std::forward<decltype(_26)>(_26), std::forward<decltype(_27)>(_27), std::forward<decltype(_28)>(_28), std::forward<decltype(_29)>(_29), std::forward<decltype(_30)>(_30), std::forward<decltype(_31)>(_31));
}

template <class Fn, class T>
  requires requires { std::remove_cvref_t<T>{any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}}; }
[[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, tag<32>) noexcept {
  auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32] = std::forward<T>(t);
  return std::forward<Fn>(fn)(std::forward<decltype(_1)>(_1), std::forward<decltype(_2)>(_2), std::forward<decltype(_3)>(_3), std::forward<decltype(_4)>(_4), std::forward<decltype(_5)>(_5), std::forward<decltype(_6)>(_6), std::forward<decltype(_7)>(_7), std::forward<decltype(_8)>(_8), std::forward<decltype(_9)>(_9), std::forward<decltype(_10)>(_10), std::forward<decltype(_11)>(_11), std::forward<decltype(_12)>(_12), std::forward<decltype(_13)>(_13), std::forward<decltype(_14)>(_14), std::forward<decltype(_15)>(_15), std::forward<decltype(_16)>(_16), std::forward<decltype(_17)>(_17), std::forward<decltype(_18)>(_18), std::forward<decltype(_19)>(_19), std::forward<decltype(_20)>(_20), std::forward<decltype(_21)>(_21), std::forward<decltype(_22)>(_22), std::forward<decltype(_23)>(_23), std::forward<decltype(_24)>(_24), std::forward<decltype(_25)>(_25), std::forward<decltype(_26)>(_26), std::forward<decltype(_27)>(_27), std::forward<decltype(_28)>(_28), std::forward<decltype(_29)>(_29), std::forward<decltype(_30)>(_30), std::forward<decltype(_31)>(_31), std::forward<decltype(_32)>(_32));
}

template <class Fn, class T>
  requires requires { std::remove_cvref_t<T>{any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}}; }
[[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, tag<33>) noexcept {
  auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32, _33] = std::forward<T>(t);
  return std::forward<Fn>(fn)(std::forward<decltype(_1)>(_1), std::forward<decltype(_2)>(_2), std::forward<decltype(_3)>(_3), std::forward<decltype(_4)>(_4), std::forward<decltype(_5)>(_5), std::forward<decltype(_6)>(_6), std::forward<decltype(_7)>(_7), std::forward<decltype(_8)>(_8), std::forward<decltype(_9)>(_9), std::forward<decltype(_10)>(_10), std::forward<decltype(_11)>(_11), std::forward<decltype(_12)>(_12), std::forward<decltype(_13)>(_13), std::forward<decltype(_14)>(_14), std::forward<decltype(_15)>(_15), std::forward<decltype(_16)>(_16), std::forward<decltype(_17)>(_17), std::forward<decltype(_18)>(_18), std::forward<decltype(_19)>(_19), std::forward<decltype(_20)>(_20), std::forward<decltype(_21)>(_21), std::forward<decltype(_22)>(_22), std::forward<decltype(_23)>(_23), std::forward<decltype(_24)>(_24), std::forward<decltype(_25)>(_25), std::forward<decltype(_26)>(_26), std::forward<decltype(_27)>(_27), std::forward<decltype(_28)>(_28), std::forward<decltype(_29)>(_29), std::forward<decltype(_30)>(_30), std::forward<decltype(_31)>(_31), std::forward<decltype(_32)>(_32), std::forward<decltype(_33)>(_33));
}

template <class Fn, class T>
  requires requires { std::remove_cvref_t<T>{any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}}; }
[[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, tag<34>) noexcept {
  auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32, _33, _34] = std::forward<T>(t);
  return std::forward<Fn>(fn)(std::forward<decltype(_1)>(_1), std::forward<decltype(_2)>(_2), std::forward<decltype(_3)>(_3), std::forward<decltype(_4)>(_4), std::forward<decltype(_5)>(_5), std::forward<decltype(_6)>(_6), std::forward<decltype(_7)>(_7), std::forward<decltype(_8)>(_8), std::forward<decltype(_9)>(_9), std::forward<decltype(_10)>(_10), std::forward<decltype(_11)>(_11), std::forward<decltype(_12)>(_12), std::forward<decltype(_13)>(_13), std::forward<decltype(_14)>(_14), std::forward<decltype(_15)>(_15), std::forward<decltype(_16)>(_16), std::forward<decltype(_17)>(_17), std::forward<decltype(_18)>(_18), std::forward<decltype(_19)>(_19), std::forward<decltype(_20)>(_20), std::forward<decltype(_21)>(_21), std::forward<decltype(_22)>(_22), std::forward<decltype(_23)>(_23), std::forward<decltype(_24)>(_24), std::forward<decltype(_25)>(_25), std::forward<decltype(_26)>(_26), std::forward<decltype(_27)>(_27), std::forward<decltype(_28)>(_28), std::forward<decltype(_29)>(_29), std::forward<decltype(_30)>(_30), std::forward<decltype(_31)>(_31), std::forward<decltype(_32)>(_32), std::forward<decltype(_33)>(_33), std::forward<decltype(_34)>(_34));
}

template <class Fn, class T>
  requires requires { std::remove_cvref_t<T>{any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}}; }
[[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, tag<35>) noexcept {
  auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32, _33, _34, _35] = std::forward<T>(t);
  return std::forward<Fn>(fn)(std::forward<decltype(_1)>(_1), std::forward<decltype(_2)>(_2), std::forward<decltype(_3)>(_3), std::forward<decltype(_4)>(_4), std::forward<decltype(_5)>(_5), std::forward<decltype(_6)>(_6), std::forward<decltype(_7)>(_7), std::forward<decltype(_8)>(_8), std::forward<decltype(_9)>(_9), std::forward<decltype(_10)>(_10), std::forward<decltype(_11)>(_11), std::forward<decltype(_12)>(_12), std::forward<decltype(_13)>(_13), std::forward<decltype(_14)>(_14), std::forward<decltype(_15)>(_15), std::forward<decltype(_16)>(_16), std::forward<decltype(_17)>(_17), std::forward<decltype(_18)>(_18), std::forward<decltype(_19)>(_19), std::forward<decltype(_20)>(_20), std::forward<decltype(_21)>(_21), std::forward<decltype(_22)>(_22), std::forward<decltype(_23)>(_23), std::forward<decltype(_24)>(_24), std::forward<decltype(_25)>(_25), std::forward<decltype(_26)>(_26), std::forward<decltype(_27)>(_27), std::forward<decltype(_28)>(_28), std::forward<decltype(_29)>(_29), std::forward<decltype(_30)>(_30), std::forward<decltype(_31)>(_31), std::forward<decltype(_32)>(_32), std::forward<decltype(_33)>(_33), std::forward<decltype(_34)>(_34), std::forward<decltype(_35)>(_35));
}

template <class Fn, class T>
  requires requires { std::remove_cvref_t<T>{any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}}; }
[[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, tag<36>) noexcept {
  auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32, _33, _34, _35, _36] = std::forward<T>(t);
  return std::forward<Fn>(fn)(std::forward<decltype(_1)>(_1), std::forward<decltype(_2)>(_2), std::forward<decltype(_3)>(_3), std::forward<decltype(_4)>(_4), std::forward<decltype(_5)>(_5), std::forward<decltype(_6)>(_6), std::forward<decltype(_7)>(_7), std::forward<decltype(_8)>(_8), std::forward<decltype(_9)>(_9), std::forward<decltype(_10)>(_10), std::forward<decltype(_11)>(_11), std::forward<decltype(_12)>(_12), std::forward<decltype(_13)>(_13), std::forward<decltype(_14)>(_14), std::forward<decltype(_15)>(_15), std::forward<decltype(_16)>(_16), std::forward<decltype(_17)>(_17), std::forward<decltype(_18)>(_18), std::forward<decltype(_19)>(_19), std::forward<decltype(_20)>(_20), std::forward<decltype(_21)>(_21), std::forward<decltype(_22)>(_22), std::forward<decltype(_23)>(_23), std::forward<decltype(_24)>(_24), std::forward<decltype(_25)>(_25), std::forward<decltype(_26)>(_26), std::forward<decltype(_27)>(_27), std::forward<decltype(_28)>(_28), std::forward<decltype(_29)>(_29), std::forward<decltype(_30)>(_30), std::forward<decltype(_31)>(_31), std::forward<decltype(_32)>(_32), std::forward<decltype(_33)>(_33), std::forward<decltype(_34)>(_34), std::forward<decltype(_35)>(_35), std::forward<decltype(_36)>(_36));
}

template <class Fn, class T>
  requires requires { std::remove_cvref_t<T>{any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}}; }
[[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, tag<37>) noexcept {
  auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37] = std::forward<T>(t);
  return std::forward<Fn>(fn)(std::forward<decltype(_1)>(_1), std::forward<decltype(_2)>(_2), std::forward<decltype(_3)>(_3), std::forward<decltype(_4)>(_4), std::forward<decltype(_5)>(_5), std::forward<decltype(_6)>(_6), std::forward<decltype(_7)>(_7), std::forward<decltype(_8)>(_8), std::forward<decltype(_9)>(_9), std::forward<decltype(_10)>(_10), std::forward<decltype(_11)>(_11), std::forward<decltype(_12)>(_12), std::forward<decltype(_13)>(_13), std::forward<decltype(_14)>(_14), std::forward<decltype(_15)>(_15), std::forward<decltype(_16)>(_16), std::forward<decltype(_17)>(_17), std::forward<decltype(_18)>(_18), std::forward<decltype(_19)>(_19), std::forward<decltype(_20)>(_20), std::forward<decltype(_21)>(_21), std::forward<decltype(_22)>(_22), std::forward<decltype(_23)>(_23), std::forward<decltype(_24)>(_24), std::forward<decltype(_25)>(_25), std::forward<decltype(_26)>(_26), std::forward<decltype(_27)>(_27), std::forward<decltype(_28)>(_28), std::forward<decltype(_29)>(_29), std::forward<decltype(_30)>(_30), std::forward<decltype(_31)>(_31), std::forward<decltype(_32)>(_32), std::forward<decltype(_33)>(_33), std::forward<decltype(_34)>(_34), std::forward<decltype(_35)>(_35), std::forward<decltype(_36)>(_36), std::forward<decltype(_37)>(_37));
}

template <class Fn, class T>
  requires requires { std::remove_cvref_t<T>{any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}}; }
[[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, tag<38>) noexcept {
  auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38] = std::forward<T>(t);
  return std::forward<Fn>(fn)(std::forward<decltype(_1)>(_1), std::forward<decltype(_2)>(_2), std::forward<decltype(_3)>(_3), std::forward<decltype(_4)>(_4), std::forward<decltype(_5)>(_5), std::forward<decltype(_6)>(_6), std::forward<decltype(_7)>(_7), std::forward<decltype(_8)>(_8), std::forward<decltype(_9)>(_9), std::forward<decltype(_10)>(_10), std::forward<decltype(_11)>(_11), std::forward<decltype(_12)>(_12), std::forward<decltype(_13)>(_13), std::forward<decltype(_14)>(_14), std::forward<decltype(_15)>(_15), std::forward<decltype(_16)>(_16), std::forward<decltype(_17)>(_17), std::forward<decltype(_18)>(_18), std::forward<decltype(_19)>(_19), std::forward<decltype(_20)>(_20), std::forward<decltype(_21)>(_21), std::forward<decltype(_22)>(_22), std::forward<decltype(_23)>(_23), std::forward<decltype(_24)>(_24), std::forward<decltype(_25)>(_25), std::forward<decltype(_26)>(_26), std::forward<decltype(_27)>(_27), std::forward<decltype(_28)>(_28), std::forward<decltype(_29)>(_29), std::forward<decltype(_30)>(_30), std::forward<decltype(_31)>(_31), std::forward<decltype(_32)>(_32), std::forward<decltype(_33)>(_33), std::forward<decltype(_34)>(_34), std::forward<decltype(_35)>(_35), std::forward<decltype(_36)>(_36), std::forward<decltype(_37)>(_37), std::forward<decltype(_38)>(_38));
}

template <class Fn, class T>
  requires requires { std::remove_cvref_t<T>{any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}}; }
[[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, tag<39>) noexcept {
  auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39] = std::forward<T>(t);
  return std::forward<Fn>(fn)(std::forward<decltype(_1)>(_1), std::forward<decltype(_2)>(_2), std::forward<decltype(_3)>(_3), std::forward<decltype(_4)>(_4), std::forward<decltype(_5)>(_5), std::forward<decltype(_6)>(_6), std::forward<decltype(_7)>(_7), std::forward<decltype(_8)>(_8), std::forward<decltype(_9)>(_9), std::forward<decltype(_10)>(_10), std::forward<decltype(_11)>(_11), std::forward<decltype(_12)>(_12), std::forward<decltype(_13)>(_13), std::forward<decltype(_14)>(_14), std::forward<decltype(_15)>(_15), std::forward<decltype(_16)>(_16), std::forward<decltype(_17)>(_17), std::forward<decltype(_18)>(_18), std::forward<decltype(_19)>(_19), std::forward<decltype(_20)>(_20), std::forward<decltype(_21)>(_21), std::forward<decltype(_22)>(_22), std::forward<decltype(_23)>(_23), std::forward<decltype(_24)>(_24), std::forward<decltype(_25)>(_25), std::forward<decltype(_26)>(_26), std::forward<decltype(_27)>(_27), std::forward<decltype(_28)>(_28), std::forward<decltype(_29)>(_29), std::forward<decltype(_30)>(_30), std::forward<decltype(_31)>(_31), std::forward<decltype(_32)>(_32), std::forward<decltype(_33)>(_33), std::forward<decltype(_34)>(_34), std::forward<decltype(_35)>(_35), std::forward<decltype(_36)>(_36), std::forward<decltype(_37)>(_37), std::forward<decltype(_38)>(_38), std::forward<decltype(_39)>(_39));
}

template <class Fn, class T>
  requires requires { std::remove_cvref_t<T>{any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}}; }
[[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, tag<40>) noexcept {
  auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40] = std::forward<T>(t);
  return std::forward<Fn>(fn)(std::forward<decltype(_1)>(_1), std::forward<decltype(_2)>(_2), std::forward<decltype(_3)>(_3), std::forward<decltype(_4)>(_4), std::forward<decltype(_5)>(_5), std::forward<decltype(_6)>(_6), std::forward<decltype(_7)>(_7), std::forward<decltype(_8)>(_8), std::forward<decltype(_9)>(_9), std::forward<decltype(_10)>(_10), std::forward<decltype(_11)>(_11), std::forward<decltype(_12)>(_12), std::forward<decltype(_13)>(_13), std::forward<decltype(_14)>(_14), std::forward<decltype(_15)>(_15), std::forward<decltype(_16)>(_16), std::forward<decltype(_17)>(_17), std::forward<decltype(_18)>(_18), std::forward<decltype(_19)>(_19), std::forward<decltype(_20)>(_20), std::forward<decltype(_21)>(_21), std::forward<decltype(_22)>(_22), std::forward<decltype(_23)>(_23), std::forward<decltype(_24)>(_24), std::forward<decltype(_25)>(_25), std::forward<decltype(_26)>(_26), std::forward<decltype(_27)>(_27), std::forward<decltype(_28)>(_28), std::forward<decltype(_29)>(_29), std::forward<decltype(_30)>(_30), std::forward<decltype(_31)>(_31), std::forward<decltype(_32)>(_32), std::forward<decltype(_33)>(_33), std::forward<decltype(_34)>(_34), std::forward<decltype(_35)>(_35), std::forward<decltype(_36)>(_36), std::forward<decltype(_37)>(_37), std::forward<decltype(_38)>(_38), std::forward<decltype(_39)>(_39), std::forward<decltype(_40)>(_40));
}

template <class Fn, class T>
  requires requires { std::remove_cvref_t<T>{any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}}; }
[[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, tag<41>) noexcept {
  auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41] = std::forward<T>(t);
  return std::forward<Fn>(fn)(std::forward<decltype(_1)>(_1), std::forward<decltype(_2)>(_2), std::forward<decltype(_3)>(_3), std::forward<decltype(_4)>(_4), std::forward<decltype(_5)>(_5), std::forward<decltype(_6)>(_6), std::forward<decltype(_7)>(_7), std::forward<decltype(_8)>(_8), std::forward<decltype(_9)>(_9), std::forward<decltype(_10)>(_10), std::forward<decltype(_11)>(_11), std::forward<decltype(_12)>(_12), std::forward<decltype(_13)>(_13), std::forward<decltype(_14)>(_14), std::forward<decltype(_15)>(_15), std::forward<decltype(_16)>(_16), std::forward<decltype(_17)>(_17), std::forward<decltype(_18)>(_18), std::forward<decltype(_19)>(_19), std::forward<decltype(_20)>(_20), std::forward<decltype(_21)>(_21), std::forward<decltype(_22)>(_22), std::forward<decltype(_23)>(_23), std::forward<decltype(_24)>(_24), std::forward<decltype(_25)>(_25), std::forward<decltype(_26)>(_26), std::forward<decltype(_27)>(_27), std::forward<decltype(_28)>(_28), std::forward<decltype(_29)>(_29), std::forward<decltype(_30)>(_30), std::forward<decltype(_31)>(_31), std::forward<decltype(_32)>(_32), std::forward<decltype(_33)>(_33), std::forward<decltype(_34)>(_34), std::forward<decltype(_35)>(_35), std::forward<decltype(_36)>(_36), std::forward<decltype(_37)>(_37), std::forward<decltype(_38)>(_38), std::forward<decltype(_39)>(_39), std::forward<decltype(_40)>(_40), std::forward<decltype(_41)>(_41));
}

template <class Fn, class T>
  requires requires { std::remove_cvref_t<T>{any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}}; }
[[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, tag<42>) noexcept {
  auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42] = std::forward<T>(t);
  return std::forward<Fn>(fn)(std::forward<decltype(_1)>(_1), std::forward<decltype(_2)>(_2), std::forward<decltype(_3)>(_3), std::forward<decltype(_4)>(_4), std::forward<decltype(_5)>(_5), std::forward<decltype(_6)>(_6), std::forward<decltype(_7)>(_7), std::forward<decltype(_8)>(_8), std::forward<decltype(_9)>(_9), std::forward<decltype(_10)>(_10), std::forward<decltype(_11)>(_11), std::forward<decltype(_12)>(_12), std::forward<decltype(_13)>(_13), std::forward<decltype(_14)>(_14), std::forward<decltype(_15)>(_15), std::forward<decltype(_16)>(_16), std::forward<decltype(_17)>(_17), std::forward<decltype(_18)>(_18), std::forward<decltype(_19)>(_19), std::forward<decltype(_20)>(_20), std::forward<decltype(_21)>(_21), std::forward<decltype(_22)>(_22), std::forward<decltype(_23)>(_23), std::forward<decltype(_24)>(_24), std::forward<decltype(_25)>(_25), std::forward<decltype(_26)>(_26), std::forward<decltype(_27)>(_27), std::forward<decltype(_28)>(_28), std::forward<decltype(_29)>(_29), std::forward<decltype(_30)>(_30), std::forward<decltype(_31)>(_31), std::forward<decltype(_32)>(_32), std::forward<decltype(_33)>(_33), std::forward<decltype(_34)>(_34), std::forward<decltype(_35)>(_35), std::forward<decltype(_36)>(_36), std::forward<decltype(_37)>(_37), std::forward<decltype(_38)>(_38), std::forward<decltype(_39)>(_39), std::forward<decltype(_40)>(_40), std::forward<decltype(_41)>(_41), std::forward<decltype(_42)>(_42));
}

template <class Fn, class T>
  requires requires { std::remove_cvref_t<T>{any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}}; }
[[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, tag<43>) noexcept {
  auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43] = std::forward<T>(t);
  return std::forward<Fn>(fn)(std::forward<decltype(_1)>(_1), std::forward<decltype(_2)>(_2), std::forward<decltype(_3)>(_3), std::forward<decltype(_4)>(_4), std::forward<decltype(_5)>(_5), std::forward<decltype(_6)>(_6), std::forward<decltype(_7)>(_7), std::forward<decltype(_8)>(_8), std::forward<decltype(_9)>(_9), std::forward<decltype(_10)>(_10), std::forward<decltype(_11)>(_11), std::forward<decltype(_12)>(_12), std::forward<decltype(_13)>(_13), std::forward<decltype(_14)>(_14), std::forward<decltype(_15)>(_15), std::forward<decltype(_16)>(_16), std::forward<decltype(_17)>(_17), std::forward<decltype(_18)>(_18), std::forward<decltype(_19)>(_19), std::forward<decltype(_20)>(_20), std::forward<decltype(_21)>(_21), std::forward<decltype(_22)>(_22), std::forward<decltype(_23)>(_23), std::forward<decltype(_24)>(_24), std::forward<decltype(_25)>(_25), std::forward<decltype(_26)>(_26), std::forward<decltype(_27)>(_27), std::forward<decltype(_28)>(_28), std::forward<decltype(_29)>(_29), std::forward<decltype(_30)>(_30), std::forward<decltype(_31)>(_31), std::forward<decltype(_32)>(_32), std::forward<decltype(_33)>(_33), std::forward<decltype(_34)>(_34), std::forward<decltype(_35)>(_35), std::forward<decltype(_36)>(_36), std::forward<decltype(_37)>(_37), std::forward<decltype(_38)>(_38), std::forward<decltype(_39)>(_39), std::forward<decltype(_40)>(_40), std::forward<decltype(_41)>(_41), std::forward<decltype(_42)>(_42), std::forward<decltype(_43)>(_43));
}

template <class Fn, class T>
  requires requires { std::remove_cvref_t<T>{any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}}; }
[[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, tag<44>) noexcept {
  auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44] = std::forward<T>(t);
  return std::forward<Fn>(fn)(std::forward<decltype(_1)>(_1), std::forward<decltype(_2)>(_2), std::forward<decltype(_3)>(_3), std::forward<decltype(_4)>(_4), std::forward<decltype(_5)>(_5), std::forward<decltype(_6)>(_6), std::forward<decltype(_7)>(_7), std::forward<decltype(_8)>(_8), std::forward<decltype(_9)>(_9), std::forward<decltype(_10)>(_10), std::forward<decltype(_11)>(_11), std::forward<decltype(_12)>(_12), std::forward<decltype(_13)>(_13), std::forward<decltype(_14)>(_14), std::forward<decltype(_15)>(_15), std::forward<decltype(_16)>(_16), std::forward<decltype(_17)>(_17), std::forward<decltype(_18)>(_18), std::forward<decltype(_19)>(_19), std::forward<decltype(_20)>(_20), std::forward<decltype(_21)>(_21), std::forward<decltype(_22)>(_22), std::forward<decltype(_23)>(_23), std::forward<decltype(_24)>(_24), std::forward<decltype(_25)>(_25), std::forward<decltype(_26)>(_26), std::forward<decltype(_27)>(_27), std::forward<decltype(_28)>(_28), std::forward<decltype(_29)>(_29), std::forward<decltype(_30)>(_30), std::forward<decltype(_31)>(_31), std::forward<decltype(_32)>(_32), std::forward<decltype(_33)>(_33), std::forward<decltype(_34)>(_34), std::forward<decltype(_35)>(_35), std::forward<decltype(_36)>(_36), std::forward<decltype(_37)>(_37), std::forward<decltype(_38)>(_38), std::forward<decltype(_39)>(_39), std::forward<decltype(_40)>(_40), std::forward<decltype(_41)>(_41), std::forward<decltype(_42)>(_42), std::forward<decltype(_43)>(_43), std::forward<decltype(_44)>(_44));
}

template <class Fn, class T>
  requires requires { std::remove_cvref_t<T>{any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}}; }
[[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, tag<45>) noexcept {
  auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45] = std::forward<T>(t);
  return std::forward<Fn>(fn)(std::forward<decltype(_1)>(_1), std::forward<decltype(_2)>(_2), std::forward<decltype(_3)>(_3), std::forward<decltype(_4)>(_4), std::forward<decltype(_5)>(_5), std::forward<decltype(_6)>(_6), std::forward<decltype(_7)>(_7), std::forward<decltype(_8)>(_8), std::forward<decltype(_9)>(_9), std::forward<decltype(_10)>(_10), std::forward<decltype(_11)>(_11), std::forward<decltype(_12)>(_12), std::forward<decltype(_13)>(_13), std::forward<decltype(_14)>(_14), std::forward<decltype(_15)>(_15), std::forward<decltype(_16)>(_16), std::forward<decltype(_17)>(_17), std::forward<decltype(_18)>(_18), std::forward<decltype(_19)>(_19), std::forward<decltype(_20)>(_20), std::forward<decltype(_21)>(_21), std::forward<decltype(_22)>(_22), std::forward<decltype(_23)>(_23), std::forward<decltype(_24)>(_24), std::forward<decltype(_25)>(_25), std::forward<decltype(_26)>(_26), std::forward<decltype(_27)>(_27), std::forward<decltype(_28)>(_28), std::forward<decltype(_29)>(_29), std::forward<decltype(_30)>(_30), std::forward<decltype(_31)>(_31), std::forward<decltype(_32)>(_32), std::forward<decltype(_33)>(_33), std::forward<decltype(_34)>(_34), std::forward<decltype(_35)>(_35), std::forward<decltype(_36)>(_36), std::forward<decltype(_37)>(_37), std::forward<decltype(_38)>(_38), std::forward<decltype(_39)>(_39), std::forward<decltype(_40)>(_40), std::forward<decltype(_41)>(_41), std::forward<decltype(_42)>(_42), std::forward<decltype(_43)>(_43), std::forward<decltype(_44)>(_44), std::forward<decltype(_45)>(_45));
}

template <class Fn, class T>
  requires requires { std::remove_cvref_t<T>{any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}}; }
[[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, tag<46>) noexcept {
  auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46] = std::forward<T>(t);
  return std::forward<Fn>(fn)(std::forward<decltype(_1)>(_1), std::forward<decltype(_2)>(_2), std::forward<decltype(_3)>(_3), std::forward<decltype(_4)>(_4), std::forward<decltype(_5)>(_5), std::forward<decltype(_6)>(_6), std::forward<decltype(_7)>(_7), std::forward<decltype(_8)>(_8), std::forward<decltype(_9)>(_9), std::forward<decltype(_10)>(_10), std::forward<decltype(_11)>(_11), std::forward<decltype(_12)>(_12), std::forward<decltype(_13)>(_13), std::forward<decltype(_14)>(_14), std::forward<decltype(_15)>(_15), std::forward<decltype(_16)>(_16), std::forward<decltype(_17)>(_17), std::forward<decltype(_18)>(_18), std::forward<decltype(_19)>(_19), std::forward<decltype(_20)>(_20), std::forward<decltype(_21)>(_21), std::forward<decltype(_22)>(_22), std::forward<decltype(_23)>(_23), std::forward<decltype(_24)>(_24), std::forward<decltype(_25)>(_25), std::forward<decltype(_26)>(_26), std::forward<decltype(_27)>(_27), std::forward<decltype(_28)>(_28), std::forward<decltype(_29)>(_29), std::forward<decltype(_30)>(_30), std::forward<decltype(_31)>(_31), std::forward<decltype(_32)>(_32), std::forward<decltype(_33)>(_33), std::forward<decltype(_34)>(_34), std::forward<decltype(_35)>(_35), std::forward<decltype(_36)>(_36), std::forward<decltype(_37)>(_37), std::forward<decltype(_38)>(_38), std::forward<decltype(_39)>(_39), std::forward<decltype(_40)>(_40), std::forward<decltype(_41)>(_41), std::forward<decltype(_42)>(_42), std::forward<decltype(_43)>(_43), std::forward<decltype(_44)>(_44), std::forward<decltype(_45)>(_45), std::forward<decltype(_46)>(_46));
}

template <class Fn, class T>
  requires requires { std::remove_cvref_t<T>{any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}}; }
[[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, tag<47>) noexcept {
  auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47] = std::forward<T>(t);
  return std::forward<Fn>(fn)(std::forward<decltype(_1)>(_1), std::forward<decltype(_2)>(_2), std::forward<decltype(_3)>(_3), std::forward<decltype(_4)>(_4), std::forward<decltype(_5)>(_5), std::forward<decltype(_6)>(_6), std::forward<decltype(_7)>(_7), std::forward<decltype(_8)>(_8), std::forward<decltype(_9)>(_9), std::forward<decltype(_10)>(_10), std::forward<decltype(_11)>(_11), std::forward<decltype(_12)>(_12), std::forward<decltype(_13)>(_13), std::forward<decltype(_14)>(_14), std::forward<decltype(_15)>(_15), std::forward<decltype(_16)>(_16), std::forward<decltype(_17)>(_17), std::forward<decltype(_18)>(_18), std::forward<decltype(_19)>(_19), std::forward<decltype(_20)>(_20), std::forward<decltype(_21)>(_21), std::forward<decltype(_22)>(_22), std::forward<decltype(_23)>(_23), std::forward<decltype(_24)>(_24), std::forward<decltype(_25)>(_25), std::forward<decltype(_26)>(_26), std::forward<decltype(_27)>(_27), std::forward<decltype(_28)>(_28), std::forward<decltype(_29)>(_29), std::forward<decltype(_30)>(_30), std::forward<decltype(_31)>(_31), std::forward<decltype(_32)>(_32), std::forward<decltype(_33)>(_33), std::forward<decltype(_34)>(_34), std::forward<decltype(_35)>(_35), std::forward<decltype(_36)>(_36), std::forward<decltype(_37)>(_37), std::forward<decltype(_38)>(_38), std::forward<decltype(_39)>(_39), std::forward<decltype(_40)>(_40), std::forward<decltype(_41)>(_41), std::forward<decltype(_42)>(_42), std::forward<decltype(_43)>(_43), std::forward<decltype(_44)>(_44), std::forward<decltype(_45)>(_45), std::forward<decltype(_46)>(_46), std::forward<decltype(_47)>(_47));
}

template <class Fn, class T>
  requires requires { std::remove_cvref_t<T>{any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}}; }
[[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, tag<48>) noexcept {
  auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48] = std::forward<T>(t);
  return std::forward<Fn>(fn)(std::forward<decltype(_1)>(_1), std::forward<decltype(_2)>(_2), std::forward<decltype(_3)>(_3), std::forward<decltype(_4)>(_4), std::forward<decltype(_5)>(_5), std::forward<decltype(_6)>(_6), std::forward<decltype(_7)>(_7), std::forward<decltype(_8)>(_8), std::forward<decltype(_9)>(_9), std::forward<decltype(_10)>(_10), std::forward<decltype(_11)>(_11), std::forward<decltype(_12)>(_12), std::forward<decltype(_13)>(_13), std::forward<decltype(_14)>(_14), std::forward<decltype(_15)>(_15), std::forward<decltype(_16)>(_16), std::forward<decltype(_17)>(_17), std::forward<decltype(_18)>(_18), std::forward<decltype(_19)>(_19), std::forward<decltype(_20)>(_20), std::forward<decltype(_21)>(_21), std::forward<decltype(_22)>(_22), std::forward<decltype(_23)>(_23), std::forward<decltype(_24)>(_24), std::forward<decltype(_25)>(_25), std::forward<decltype(_26)>(_26), std::forward<decltype(_27)>(_27), std::forward<decltype(_28)>(_28), std::forward<decltype(_29)>(_29), std::forward<decltype(_30)>(_30), std::forward<decltype(_31)>(_31), std::forward<decltype(_32)>(_32), std::forward<decltype(_33)>(_33), std::forward<decltype(_34)>(_34), std::forward<decltype(_35)>(_35), std::forward<decltype(_36)>(_36), std::forward<decltype(_37)>(_37), std::forward<decltype(_38)>(_38), std::forward<decltype(_39)>(_39), std::forward<decltype(_40)>(_40), std::forward<decltype(_41)>(_41), std::forward<decltype(_42)>(_42), std::forward<decltype(_43)>(_43), std::forward<decltype(_44)>(_44), std::forward<decltype(_45)>(_45), std::forward<decltype(_46)>(_46), std::forward<decltype(_47)>(_47), std::forward<decltype(_48)>(_48));
}

template <class Fn, class T>
  requires requires { std::remove_cvref_t<T>{any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}}; }
[[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, tag<49>) noexcept {
  auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49] = std::forward<T>(t);
  return std::forward<Fn>(fn)(std::forward<decltype(_1)>(_1), std::forward<decltype(_2)>(_2), std::forward<decltype(_3)>(_3), std::forward<decltype(_4)>(_4), std::forward<decltype(_5)>(_5), std::forward<decltype(_6)>(_6), std::forward<decltype(_7)>(_7), std::forward<decltype(_8)>(_8), std::forward<decltype(_9)>(_9), std::forward<decltype(_10)>(_10), std::forward<decltype(_11)>(_11), std::forward<decltype(_12)>(_12), std::forward<decltype(_13)>(_13), std::forward<decltype(_14)>(_14), std::forward<decltype(_15)>(_15), std::forward<decltype(_16)>(_16), std::forward<decltype(_17)>(_17), std::forward<decltype(_18)>(_18), std::forward<decltype(_19)>(_19), std::forward<decltype(_20)>(_20), std::forward<decltype(_21)>(_21), std::forward<decltype(_22)>(_22), std::forward<decltype(_23)>(_23), std::forward<decltype(_24)>(_24), std::forward<decltype(_25)>(_25), std::forward<decltype(_26)>(_26), std::forward<decltype(_27)>(_27), std::forward<decltype(_28)>(_28), std::forward<decltype(_29)>(_29), std::forward<decltype(_30)>(_30), std::forward<decltype(_31)>(_31), std::forward<decltype(_32)>(_32), std::forward<decltype(_33)>(_33), std::forward<decltype(_34)>(_34), std::forward<decltype(_35)>(_35), std::forward<decltype(_36)>(_36), std::forward<decltype(_37)>(_37), std::forward<decltype(_38)>(_38), std::forward<decltype(_39)>(_39), std::forward<decltype(_40)>(_40), std::forward<decltype(_41)>(_41), std::forward<decltype(_42)>(_42), std::forward<decltype(_43)>(_43), std::forward<decltype(_44)>(_44), std::forward<decltype(_45)>(_45), std::forward<decltype(_46)>(_46), std::forward<decltype(_47)>(_47), std::forward<decltype(_48)>(_48), std::forward<decltype(_49)>(_49));
}

template <class Fn, class T>
  requires requires { std::remove_cvref_t<T>{any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}}; }
[[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, tag<50>) noexcept {
  auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50] = std::forward<T>(t);
  return std::forward<Fn>(fn)(std::forward<decltype(_1)>(_1), std::forward<decltype(_2)>(_2), std::forward<decltype(_3)>(_3), std::forward<decltype(_4)>(_4), std::forward<decltype(_5)>(_5), std::forward<decltype(_6)>(_6), std::forward<decltype(_7)>(_7), std::forward<decltype(_8)>(_8), std::forward<decltype(_9)>(_9), std::forward<decltype(_10)>(_10), std::forward<decltype(_11)>(_11), std::forward<decltype(_12)>(_12), std::forward<decltype(_13)>(_13), std::forward<decltype(_14)>(_14), std::forward<decltype(_15)>(_15), std::forward<decltype(_16)>(_16), std::forward<decltype(_17)>(_17), std::forward<decltype(_18)>(_18), std::forward<decltype(_19)>(_19), std::forward<decltype(_20)>(_20), std::forward<decltype(_21)>(_21), std::forward<decltype(_22)>(_22), std::forward<decltype(_23)>(_23), std::forward<decltype(_24)>(_24), std::forward<decltype(_25)>(_25), std::forward<decltype(_26)>(_26), std::forward<decltype(_27)>(_27), std::forward<decltype(_28)>(_28), std::forward<decltype(_29)>(_29), std::forward<decltype(_30)>(_30), std::forward<decltype(_31)>(_31), std::forward<decltype(_32)>(_32), std::forward<decltype(_33)>(_33), std::forward<decltype(_34)>(_34), std::forward<decltype(_35)>(_35), std::forward<decltype(_36)>(_36), std::forward<decltype(_37)>(_37), std::forward<decltype(_38)>(_38), std::forward<decltype(_39)>(_39), std::forward<decltype(_40)>(_40), std::forward<decltype(_41)>(_41), std::forward<decltype(_42)>(_42), std::forward<decltype(_43)>(_43), std::forward<decltype(_44)>(_44), std::forward<decltype(_45)>(_45), std::forward<decltype(_46)>(_46), std::forward<decltype(_47)>(_47), std::forward<decltype(_48)>(_48), std::forward<decltype(_49)>(_49), std::forward<decltype(_50)>(_50));
}

template <class Fn, class T>
  requires requires { std::remove_cvref_t<T>{any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}}; }
[[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, tag<51>) noexcept {
  auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50, _51] = std::forward<T>(t);
  return std::forward<Fn>(fn)(std::forward<decltype(_1)>(_1), std::forward<decltype(_2)>(_2), std::forward<decltype(_3)>(_3), std::forward<decltype(_4)>(_4), std::forward<decltype(_5)>(_5), std::forward<decltype(_6)>(_6), std::forward<decltype(_7)>(_7), std::forward<decltype(_8)>(_8), std::forward<decltype(_9)>(_9), std::forward<decltype(_10)>(_10), std::forward<decltype(_11)>(_11), std::forward<decltype(_12)>(_12), std::forward<decltype(_13)>(_13), std::forward<decltype(_14)>(_14), std::forward<decltype(_15)>(_15), std::forward<decltype(_16)>(_16), std::forward<decltype(_17)>(_17), std::forward<decltype(_18)>(_18), std::forward<decltype(_19)>(_19), std::forward<decltype(_20)>(_20), std::forward<decltype(_21)>(_21), std::forward<decltype(_22)>(_22), std::forward<decltype(_23)>(_23), std::forward<decltype(_24)>(_24), std::forward<decltype(_25)>(_25), std::forward<decltype(_26)>(_26), std::forward<decltype(_27)>(_27), std::forward<decltype(_28)>(_28), std::forward<decltype(_29)>(_29), std::forward<decltype(_30)>(_30), std::forward<decltype(_31)>(_31), std::forward<decltype(_32)>(_32), std::forward<decltype(_33)>(_33), std::forward<decltype(_34)>(_34), std::forward<decltype(_35)>(_35), std::forward<decltype(_36)>(_36), std::forward<decltype(_37)>(_37), std::forward<decltype(_38)>(_38), std::forward<decltype(_39)>(_39), std::forward<decltype(_40)>(_40), std::forward<decltype(_41)>(_41), std::forward<decltype(_42)>(_42), std::forward<decltype(_43)>(_43), std::forward<decltype(_44)>(_44), std::forward<decltype(_45)>(_45), std::forward<decltype(_46)>(_46), std::forward<decltype(_47)>(_47), std::forward<decltype(_48)>(_48), std::forward<decltype(_49)>(_49), std::forward<decltype(_50)>(_50), std::forward<decltype(_51)>(_51));
}

template <class Fn, class T>
  requires requires { std::remove_cvref_t<T>{any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}}; }
[[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, tag<52>) noexcept {
  auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50, _51, _52] = std::forward<T>(t);
  return std::forward<Fn>(fn)(std::forward<decltype(_1)>(_1), std::forward<decltype(_2)>(_2), std::forward<decltype(_3)>(_3), std::forward<decltype(_4)>(_4), std::forward<decltype(_5)>(_5), std::forward<decltype(_6)>(_6), std::forward<decltype(_7)>(_7), std::forward<decltype(_8)>(_8), std::forward<decltype(_9)>(_9), std::forward<decltype(_10)>(_10), std::forward<decltype(_11)>(_11), std::forward<decltype(_12)>(_12), std::forward<decltype(_13)>(_13), std::forward<decltype(_14)>(_14), std::forward<decltype(_15)>(_15), std::forward<decltype(_16)>(_16), std::forward<decltype(_17)>(_17), std::forward<decltype(_18)>(_18), std::forward<decltype(_19)>(_19), std::forward<decltype(_20)>(_20), std::forward<decltype(_21)>(_21), std::forward<decltype(_22)>(_22), std::forward<decltype(_23)>(_23), std::forward<decltype(_24)>(_24), std::forward<decltype(_25)>(_25), std::forward<decltype(_26)>(_26), std::forward<decltype(_27)>(_27), std::forward<decltype(_28)>(_28), std::forward<decltype(_29)>(_29), std::forward<decltype(_30)>(_30), std::forward<decltype(_31)>(_31), std::forward<decltype(_32)>(_32), std::forward<decltype(_33)>(_33), std::forward<decltype(_34)>(_34), std::forward<decltype(_35)>(_35), std::forward<decltype(_36)>(_36), std::forward<decltype(_37)>(_37), std::forward<decltype(_38)>(_38), std::forward<decltype(_39)>(_39), std::forward<decltype(_40)>(_40), std::forward<decltype(_41)>(_41), std::forward<decltype(_42)>(_42), std::forward<decltype(_43)>(_43), std::forward<decltype(_44)>(_44), std::forward<decltype(_45)>(_45), std::forward<decltype(_46)>(_46), std::forward<decltype(_47)>(_47), std::forward<decltype(_48)>(_48), std::forward<decltype(_49)>(_49), std::forward<decltype(_50)>(_50), std::forward<decltype(_51)>(_51), std::forward<decltype(_52)>(_52));
}

template <class Fn, class T>
  requires requires { std::remove_cvref_t<T>{any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}}; }
[[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, tag<53>) noexcept {
  auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50, _51, _52, _53] = std::forward<T>(t);
  return std::forward<Fn>(fn)(std::forward<decltype(_1)>(_1), std::forward<decltype(_2)>(_2), std::forward<decltype(_3)>(_3), std::forward<decltype(_4)>(_4), std::forward<decltype(_5)>(_5), std::forward<decltype(_6)>(_6), std::forward<decltype(_7)>(_7), std::forward<decltype(_8)>(_8), std::forward<decltype(_9)>(_9), std::forward<decltype(_10)>(_10), std::forward<decltype(_11)>(_11), std::forward<decltype(_12)>(_12), std::forward<decltype(_13)>(_13), std::forward<decltype(_14)>(_14), std::forward<decltype(_15)>(_15), std::forward<decltype(_16)>(_16), std::forward<decltype(_17)>(_17), std::forward<decltype(_18)>(_18), std::forward<decltype(_19)>(_19), std::forward<decltype(_20)>(_20), std::forward<decltype(_21)>(_21), std::forward<decltype(_22)>(_22), std::forward<decltype(_23)>(_23), std::forward<decltype(_24)>(_24), std::forward<decltype(_25)>(_25), std::forward<decltype(_26)>(_26), std::forward<decltype(_27)>(_27), std::forward<decltype(_28)>(_28), std::forward<decltype(_29)>(_29), std::forward<decltype(_30)>(_30), std::forward<decltype(_31)>(_31), std::forward<decltype(_32)>(_32), std::forward<decltype(_33)>(_33), std::forward<decltype(_34)>(_34), std::forward<decltype(_35)>(_35), std::forward<decltype(_36)>(_36), std::forward<decltype(_37)>(_37), std::forward<decltype(_38)>(_38), std::forward<decltype(_39)>(_39), std::forward<decltype(_40)>(_40), std::forward<decltype(_41)>(_41), std::forward<decltype(_42)>(_42), std::forward<decltype(_43)>(_43), std::forward<decltype(_44)>(_44), std::forward<decltype(_45)>(_45), std::forward<decltype(_46)>(_46), std::forward<decltype(_47)>(_47), std::forward<decltype(_48)>(_48), std::forward<decltype(_49)>(_49), std::forward<decltype(_50)>(_50), std::forward<decltype(_51)>(_51), std::forward<decltype(_52)>(_52), std::forward<decltype(_53)>(_53));
}

template <class Fn, class T>
  requires requires { std::remove_cvref_t<T>{any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}}; }
[[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, tag<54>) noexcept {
  auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50, _51, _52, _53, _54] = std::forward<T>(t);
  return std::forward<Fn>(fn)(std::forward<decltype(_1)>(_1), std::forward<decltype(_2)>(_2), std::forward<decltype(_3)>(_3), std::forward<decltype(_4)>(_4), std::forward<decltype(_5)>(_5), std::forward<decltype(_6)>(_6), std::forward<decltype(_7)>(_7), std::forward<decltype(_8)>(_8), std::forward<decltype(_9)>(_9), std::forward<decltype(_10)>(_10), std::forward<decltype(_11)>(_11), std::forward<decltype(_12)>(_12), std::forward<decltype(_13)>(_13), std::forward<decltype(_14)>(_14), std::forward<decltype(_15)>(_15), std::forward<decltype(_16)>(_16), std::forward<decltype(_17)>(_17), std::forward<decltype(_18)>(_18), std::forward<decltype(_19)>(_19), std::forward<decltype(_20)>(_20), std::forward<decltype(_21)>(_21), std::forward<decltype(_22)>(_22), std::forward<decltype(_23)>(_23), std::forward<decltype(_24)>(_24), std::forward<decltype(_25)>(_25), std::forward<decltype(_26)>(_26), std::forward<decltype(_27)>(_27), std::forward<decltype(_28)>(_28), std::forward<decltype(_29)>(_29), std::forward<decltype(_30)>(_30), std::forward<decltype(_31)>(_31), std::forward<decltype(_32)>(_32), std::forward<decltype(_33)>(_33), std::forward<decltype(_34)>(_34), std::forward<decltype(_35)>(_35), std::forward<decltype(_36)>(_36), std::forward<decltype(_37)>(_37), std::forward<decltype(_38)>(_38), std::forward<decltype(_39)>(_39), std::forward<decltype(_40)>(_40), std::forward<decltype(_41)>(_41), std::forward<decltype(_42)>(_42), std::forward<decltype(_43)>(_43), std::forward<decltype(_44)>(_44), std::forward<decltype(_45)>(_45), std::forward<decltype(_46)>(_46), std::forward<decltype(_47)>(_47), std::forward<decltype(_48)>(_48), std::forward<decltype(_49)>(_49), std::forward<decltype(_50)>(_50), std::forward<decltype(_51)>(_51), std::forward<decltype(_52)>(_52), std::forward<decltype(_53)>(_53), std::forward<decltype(_54)>(_54));
}

template <class Fn, class T>
  requires requires { std::remove_cvref_t<T>{any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}}; }
[[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, tag<55>) noexcept {
  auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50, _51, _52, _53, _54, _55] = std::forward<T>(t);
  return std::forward<Fn>(fn)(std::forward<decltype(_1)>(_1), std::forward<decltype(_2)>(_2), std::forward<decltype(_3)>(_3), std::forward<decltype(_4)>(_4), std::forward<decltype(_5)>(_5), std::forward<decltype(_6)>(_6), std::forward<decltype(_7)>(_7), std::forward<decltype(_8)>(_8), std::forward<decltype(_9)>(_9), std::forward<decltype(_10)>(_10), std::forward<decltype(_11)>(_11), std::forward<decltype(_12)>(_12), std::forward<decltype(_13)>(_13), std::forward<decltype(_14)>(_14), std::forward<decltype(_15)>(_15), std::forward<decltype(_16)>(_16), std::forward<decltype(_17)>(_17), std::forward<decltype(_18)>(_18), std::forward<decltype(_19)>(_19), std::forward<decltype(_20)>(_20), std::forward<decltype(_21)>(_21), std::forward<decltype(_22)>(_22), std::forward<decltype(_23)>(_23), std::forward<decltype(_24)>(_24), std::forward<decltype(_25)>(_25), std::forward<decltype(_26)>(_26), std::forward<decltype(_27)>(_27), std::forward<decltype(_28)>(_28), std::forward<decltype(_29)>(_29), std::forward<decltype(_30)>(_30), std::forward<decltype(_31)>(_31), std::forward<decltype(_32)>(_32), std::forward<decltype(_33)>(_33), std::forward<decltype(_34)>(_34), std::forward<decltype(_35)>(_35), std::forward<decltype(_36)>(_36), std::forward<decltype(_37)>(_37), std::forward<decltype(_38)>(_38), std::forward<decltype(_39)>(_39), std::forward<decltype(_40)>(_40), std::forward<decltype(_41)>(_41), std::forward<decltype(_42)>(_42), std::forward<decltype(_43)>(_43), std::forward<decltype(_44)>(_44), std::forward<decltype(_45)>(_45), std::forward<decltype(_46)>(_46), std::forward<decltype(_47)>(_47), std::forward<decltype(_48)>(_48), std::forward<decltype(_49)>(_49), std::forward<decltype(_50)>(_50), std::forward<decltype(_51)>(_51), std::forward<decltype(_52)>(_52), std::forward<decltype(_53)>(_53), std::forward<decltype(_54)>(_54), std::forward<decltype(_55)>(_55));
}

template <class Fn, class T>
  requires requires { std::remove_cvref_t<T>{any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}}; }
[[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, tag<56>) noexcept {
  auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50, _51, _52, _53, _54, _55, _56] = std::forward<T>(t);
  return std::forward<Fn>(fn)(std::forward<decltype(_1)>(_1), std::forward<decltype(_2)>(_2), std::forward<decltype(_3)>(_3), std::forward<decltype(_4)>(_4), std::forward<decltype(_5)>(_5), std::forward<decltype(_6)>(_6), std::forward<decltype(_7)>(_7), std::forward<decltype(_8)>(_8), std::forward<decltype(_9)>(_9), std::forward<decltype(_10)>(_10), std::forward<decltype(_11)>(_11), std::forward<decltype(_12)>(_12), std::forward<decltype(_13)>(_13), std::forward<decltype(_14)>(_14), std::forward<decltype(_15)>(_15), std::forward<decltype(_16)>(_16), std::forward<decltype(_17)>(_17), std::forward<decltype(_18)>(_18), std::forward<decltype(_19)>(_19), std::forward<decltype(_20)>(_20), std::forward<decltype(_21)>(_21), std::forward<decltype(_22)>(_22), std::forward<decltype(_23)>(_23), std::forward<decltype(_24)>(_24), std::forward<decltype(_25)>(_25), std::forward<decltype(_26)>(_26), std::forward<decltype(_27)>(_27), std::forward<decltype(_28)>(_28), std::forward<decltype(_29)>(_29), std::forward<decltype(_30)>(_30), std::forward<decltype(_31)>(_31), std::forward<decltype(_32)>(_32), std::forward<decltype(_33)>(_33), std::forward<decltype(_34)>(_34), std::forward<decltype(_35)>(_35), std::forward<decltype(_36)>(_36), std::forward<decltype(_37)>(_37), std::forward<decltype(_38)>(_38), std::forward<decltype(_39)>(_39), std::forward<decltype(_40)>(_40), std::forward<decltype(_41)>(_41), std::forward<decltype(_42)>(_42), std::forward<decltype(_43)>(_43), std::forward<decltype(_44)>(_44), std::forward<decltype(_45)>(_45), std::forward<decltype(_46)>(_46), std::forward<decltype(_47)>(_47), std::forward<decltype(_48)>(_48), std::forward<decltype(_49)>(_49), std::forward<decltype(_50)>(_50), std::forward<decltype(_51)>(_51), std::forward<decltype(_52)>(_52), std::forward<decltype(_53)>(_53), std::forward<decltype(_54)>(_54), std::forward<decltype(_55)>(_55), std::forward<decltype(_56)>(_56));
}

template <class Fn, class T>
  requires requires { std::remove_cvref_t<T>{any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}}; }
[[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, tag<57>) noexcept {
  auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50, _51, _52, _53, _54, _55, _56, _57] = std::forward<T>(t);
  return std::forward<Fn>(fn)(std::forward<decltype(_1)>(_1), std::forward<decltype(_2)>(_2), std::forward<decltype(_3)>(_3), std::forward<decltype(_4)>(_4), std::forward<decltype(_5)>(_5), std::forward<decltype(_6)>(_6), std::forward<decltype(_7)>(_7), std::forward<decltype(_8)>(_8), std::forward<decltype(_9)>(_9), std::forward<decltype(_10)>(_10), std::forward<decltype(_11)>(_11), std::forward<decltype(_12)>(_12), std::forward<decltype(_13)>(_13), std::forward<decltype(_14)>(_14), std::forward<decltype(_15)>(_15), std::forward<decltype(_16)>(_16), std::forward<decltype(_17)>(_17), std::forward<decltype(_18)>(_18), std::forward<decltype(_19)>(_19), std::forward<decltype(_20)>(_20), std::forward<decltype(_21)>(_21), std::forward<decltype(_22)>(_22), std::forward<decltype(_23)>(_23), std::forward<decltype(_24)>(_24), std::forward<decltype(_25)>(_25), std::forward<decltype(_26)>(_26), std::forward<decltype(_27)>(_27), std::forward<decltype(_28)>(_28), std::forward<decltype(_29)>(_29), std::forward<decltype(_30)>(_30), std::forward<decltype(_31)>(_31), std::forward<decltype(_32)>(_32), std::forward<decltype(_33)>(_33), std::forward<decltype(_34)>(_34), std::forward<decltype(_35)>(_35), std::forward<decltype(_36)>(_36), std::forward<decltype(_37)>(_37), std::forward<decltype(_38)>(_38), std::forward<decltype(_39)>(_39), std::forward<decltype(_40)>(_40), std::forward<decltype(_41)>(_41), std::forward<decltype(_42)>(_42), std::forward<decltype(_43)>(_43), std::forward<decltype(_44)>(_44), std::forward<decltype(_45)>(_45), std::forward<decltype(_46)>(_46), std::forward<decltype(_47)>(_47), std::forward<decltype(_48)>(_48), std::forward<decltype(_49)>(_49), std::forward<decltype(_50)>(_50), std::forward<decltype(_51)>(_51), std::forward<decltype(_52)>(_52), std::forward<decltype(_53)>(_53), std::forward<decltype(_54)>(_54), std::forward<decltype(_55)>(_55), std::forward<decltype(_56)>(_56), std::forward<decltype(_57)>(_57));
}

template <class Fn, class T>
  requires requires { std::remove_cvref_t<T>{any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}}; }
[[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, tag<58>) noexcept {
  auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50, _51, _52, _53, _54, _55, _56, _57, _58] = std::forward<T>(t);
  return std::forward<Fn>(fn)(std::forward<decltype(_1)>(_1), std::forward<decltype(_2)>(_2), std::forward<decltype(_3)>(_3), std::forward<decltype(_4)>(_4), std::forward<decltype(_5)>(_5), std::forward<decltype(_6)>(_6), std::forward<decltype(_7)>(_7), std::forward<decltype(_8)>(_8), std::forward<decltype(_9)>(_9), std::forward<decltype(_10)>(_10), std::forward<decltype(_11)>(_11), std::forward<decltype(_12)>(_12), std::forward<decltype(_13)>(_13), std::forward<decltype(_14)>(_14), std::forward<decltype(_15)>(_15), std::forward<decltype(_16)>(_16), std::forward<decltype(_17)>(_17), std::forward<decltype(_18)>(_18), std::forward<decltype(_19)>(_19), std::forward<decltype(_20)>(_20), std::forward<decltype(_21)>(_21), std::forward<decltype(_22)>(_22), std::forward<decltype(_23)>(_23), std::forward<decltype(_24)>(_24), std::forward<decltype(_25)>(_25), std::forward<decltype(_26)>(_26), std::forward<decltype(_27)>(_27), std::forward<decltype(_28)>(_28), std::forward<decltype(_29)>(_29), std::forward<decltype(_30)>(_30), std::forward<decltype(_31)>(_31), std::forward<decltype(_32)>(_32), std::forward<decltype(_33)>(_33), std::forward<decltype(_34)>(_34), std::forward<decltype(_35)>(_35), std::forward<decltype(_36)>(_36), std::forward<decltype(_37)>(_37), std::forward<decltype(_38)>(_38), std::forward<decltype(_39)>(_39), std::forward<decltype(_40)>(_40), std::forward<decltype(_41)>(_41), std::forward<decltype(_42)>(_42), std::forward<decltype(_43)>(_43), std::forward<decltype(_44)>(_44), std::forward<decltype(_45)>(_45), std::forward<decltype(_46)>(_46), std::forward<decltype(_47)>(_47), std::forward<decltype(_48)>(_48), std::forward<decltype(_49)>(_49), std::forward<decltype(_50)>(_50), std::forward<decltype(_51)>(_51), std::forward<decltype(_52)>(_52), std::forward<decltype(_53)>(_53), std::forward<decltype(_54)>(_54), std::forward<decltype(_55)>(_55), std::forward<decltype(_56)>(_56), std::forward<decltype(_57)>(_57), std::forward<decltype(_58)>(_58));
}

template <class Fn, class T>
  requires requires { std::remove_cvref_t<T>{any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}}; }
[[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, tag<59>) noexcept {
  auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50, _51, _52, _53, _54, _55, _56, _57, _58, _59] = std::forward<T>(t);
  return std::forward<Fn>(fn)(std::forward<decltype(_1)>(_1), std::forward<decltype(_2)>(_2), std::forward<decltype(_3)>(_3), std::forward<decltype(_4)>(_4), std::forward<decltype(_5)>(_5), std::forward<decltype(_6)>(_6), std::forward<decltype(_7)>(_7), std::forward<decltype(_8)>(_8), std::forward<decltype(_9)>(_9), std::forward<decltype(_10)>(_10), std::forward<decltype(_11)>(_11), std::forward<decltype(_12)>(_12), std::forward<decltype(_13)>(_13), std::forward<decltype(_14)>(_14), std::forward<decltype(_15)>(_15), std::forward<decltype(_16)>(_16), std::forward<decltype(_17)>(_17), std::forward<decltype(_18)>(_18), std::forward<decltype(_19)>(_19), std::forward<decltype(_20)>(_20), std::forward<decltype(_21)>(_21), std::forward<decltype(_22)>(_22), std::forward<decltype(_23)>(_23), std::forward<decltype(_24)>(_24), std::forward<decltype(_25)>(_25), std::forward<decltype(_26)>(_26), std::forward<decltype(_27)>(_27), std::forward<decltype(_28)>(_28), std::forward<decltype(_29)>(_29), std::forward<decltype(_30)>(_30), std::forward<decltype(_31)>(_31), std::forward<decltype(_32)>(_32), std::forward<decltype(_33)>(_33), std::forward<decltype(_34)>(_34), std::forward<decltype(_35)>(_35), std::forward<decltype(_36)>(_36), std::forward<decltype(_37)>(_37), std::forward<decltype(_38)>(_38), std::forward<decltype(_39)>(_39), std::forward<decltype(_40)>(_40), std::forward<decltype(_41)>(_41), std::forward<decltype(_42)>(_42), std::forward<decltype(_43)>(_43), std::forward<decltype(_44)>(_44), std::forward<decltype(_45)>(_45), std::forward<decltype(_46)>(_46), std::forward<decltype(_47)>(_47), std::forward<decltype(_48)>(_48), std::forward<decltype(_49)>(_49), std::forward<decltype(_50)>(_50), std::forward<decltype(_51)>(_51), std::forward<decltype(_52)>(_52), std::forward<decltype(_53)>(_53), std::forward<decltype(_54)>(_54), std::forward<decltype(_55)>(_55), std::forward<decltype(_56)>(_56), std::forward<decltype(_57)>(_57), std::forward<decltype(_58)>(_58), std::forward<decltype(_59)>(_59));
}

template <class Fn, class T>
  requires requires { std::remove_cvref_t<T>{any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}}; }
[[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, tag<60>) noexcept {
  auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50, _51, _52, _53, _54, _55, _56, _57, _58, _59, _60] = std::forward<T>(t);
  return std::forward<Fn>(fn)(std::forward<decltype(_1)>(_1), std::forward<decltype(_2)>(_2), std::forward<decltype(_3)>(_3), std::forward<decltype(_4)>(_4), std::forward<decltype(_5)>(_5), std::forward<decltype(_6)>(_6), std::forward<decltype(_7)>(_7), std::forward<decltype(_8)>(_8), std::forward<decltype(_9)>(_9), std::forward<decltype(_10)>(_10), std::forward<decltype(_11)>(_11), std::forward<decltype(_12)>(_12), std::forward<decltype(_13)>(_13), std::forward<decltype(_14)>(_14), std::forward<decltype(_15)>(_15), std::forward<decltype(_16)>(_16), std::forward<decltype(_17)>(_17), std::forward<decltype(_18)>(_18), std::forward<decltype(_19)>(_19), std::forward<decltype(_20)>(_20), std::forward<decltype(_21)>(_21), std::forward<decltype(_22)>(_22), std::forward<decltype(_23)>(_23), std::forward<decltype(_24)>(_24), std::forward<decltype(_25)>(_25), std::forward<decltype(_26)>(_26), std::forward<decltype(_27)>(_27), std::forward<decltype(_28)>(_28), std::forward<decltype(_29)>(_29), std::forward<decltype(_30)>(_30), std::forward<decltype(_31)>(_31), std::forward<decltype(_32)>(_32), std::forward<decltype(_33)>(_33), std::forward<decltype(_34)>(_34), std::forward<decltype(_35)>(_35), std::forward<decltype(_36)>(_36), std::forward<decltype(_37)>(_37), std::forward<decltype(_38)>(_38), std::forward<decltype(_39)>(_39), std::forward<decltype(_40)>(_40), std::forward<decltype(_41)>(_41), std::forward<decltype(_42)>(_42), std::forward<decltype(_43)>(_43), std::forward<decltype(_44)>(_44), std::forward<decltype(_45)>(_45), std::forward<decltype(_46)>(_46), std::forward<decltype(_47)>(_47), std::forward<decltype(_48)>(_48), std::forward<decltype(_49)>(_49), std::forward<decltype(_50)>(_50), std::forward<decltype(_51)>(_51), std::forward<decltype(_52)>(_52), std::forward<decltype(_53)>(_53), std::forward<decltype(_54)>(_54), std::forward<decltype(_55)>(_55), std::forward<decltype(_56)>(_56), std::forward<decltype(_57)>(_57), std::forward<decltype(_58)>(_58), std::forward<decltype(_59)>(_59), std::forward<decltype(_60)>(_60));
}

template <class Fn, class T>
  requires requires { std::remove_cvref_t<T>{any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}}; }
[[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, tag<61>) noexcept {
  auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50, _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61] = std::forward<T>(t);
  return std::forward<Fn>(fn)(std::forward<decltype(_1)>(_1), std::forward<decltype(_2)>(_2), std::forward<decltype(_3)>(_3), std::forward<decltype(_4)>(_4), std::forward<decltype(_5)>(_5), std::forward<decltype(_6)>(_6), std::forward<decltype(_7)>(_7), std::forward<decltype(_8)>(_8), std::forward<decltype(_9)>(_9), std::forward<decltype(_10)>(_10), std::forward<decltype(_11)>(_11), std::forward<decltype(_12)>(_12), std::forward<decltype(_13)>(_13), std::forward<decltype(_14)>(_14), std::forward<decltype(_15)>(_15), std::forward<decltype(_16)>(_16), std::forward<decltype(_17)>(_17), std::forward<decltype(_18)>(_18), std::forward<decltype(_19)>(_19), std::forward<decltype(_20)>(_20), std::forward<decltype(_21)>(_21), std::forward<decltype(_22)>(_22), std::forward<decltype(_23)>(_23), std::forward<decltype(_24)>(_24), std::forward<decltype(_25)>(_25), std::forward<decltype(_26)>(_26), std::forward<decltype(_27)>(_27), std::forward<decltype(_28)>(_28), std::forward<decltype(_29)>(_29), std::forward<decltype(_30)>(_30), std::forward<decltype(_31)>(_31), std::forward<decltype(_32)>(_32), std::forward<decltype(_33)>(_33), std::forward<decltype(_34)>(_34), std::forward<decltype(_35)>(_35), std::forward<decltype(_36)>(_36), std::forward<decltype(_37)>(_37), std::forward<decltype(_38)>(_38), std::forward<decltype(_39)>(_39), std::forward<decltype(_40)>(_40), std::forward<decltype(_41)>(_41), std::forward<decltype(_42)>(_42), std::forward<decltype(_43)>(_43), std::forward<decltype(_44)>(_44), std::forward<decltype(_45)>(_45), std::forward<decltype(_46)>(_46), std::forward<decltype(_47)>(_47), std::forward<decltype(_48)>(_48), std::forward<decltype(_49)>(_49), std::forward<decltype(_50)>(_50), std::forward<decltype(_51)>(_51), std::forward<decltype(_52)>(_52), std::forward<decltype(_53)>(_53), std::forward<decltype(_54)>(_54), std::forward<decltype(_55)>(_55), std::forward<decltype(_56)>(_56), std::forward<decltype(_57)>(_57), std::forward<decltype(_58)>(_58), std::forward<decltype(_59)>(_59), std::forward<decltype(_60)>(_60), std::forward<decltype(_61)>(_61));
}

template <class Fn, class T>
  requires requires { std::remove_cvref_t<T>{any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}}; }
[[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, tag<62>) noexcept {
  auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50, _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62] = std::forward<T>(t);
  return std::forward<Fn>(fn)(std::forward<decltype(_1)>(_1), std::forward<decltype(_2)>(_2), std::forward<decltype(_3)>(_3), std::forward<decltype(_4)>(_4), std::forward<decltype(_5)>(_5), std::forward<decltype(_6)>(_6), std::forward<decltype(_7)>(_7), std::forward<decltype(_8)>(_8), std::forward<decltype(_9)>(_9), std::forward<decltype(_10)>(_10), std::forward<decltype(_11)>(_11), std::forward<decltype(_12)>(_12), std::forward<decltype(_13)>(_13), std::forward<decltype(_14)>(_14), std::forward<decltype(_15)>(_15), std::forward<decltype(_16)>(_16), std::forward<decltype(_17)>(_17), std::forward<decltype(_18)>(_18), std::forward<decltype(_19)>(_19), std::forward<decltype(_20)>(_20), std::forward<decltype(_21)>(_21), std::forward<decltype(_22)>(_22), std::forward<decltype(_23)>(_23), std::forward<decltype(_24)>(_24), std::forward<decltype(_25)>(_25), std::forward<decltype(_26)>(_26), std::forward<decltype(_27)>(_27), std::forward<decltype(_28)>(_28), std::forward<decltype(_29)>(_29), std::forward<decltype(_30)>(_30), std::forward<decltype(_31)>(_31), std::forward<decltype(_32)>(_32), std::forward<decltype(_33)>(_33), std::forward<decltype(_34)>(_34), std::forward<decltype(_35)>(_35), std::forward<decltype(_36)>(_36), std::forward<decltype(_37)>(_37), std::forward<decltype(_38)>(_38), std::forward<decltype(_39)>(_39), std::forward<decltype(_40)>(_40), std::forward<decltype(_41)>(_41), std::forward<decltype(_42)>(_42), std::forward<decltype(_43)>(_43), std::forward<decltype(_44)>(_44), std::forward<decltype(_45)>(_45), std::forward<decltype(_46)>(_46), std::forward<decltype(_47)>(_47), std::forward<decltype(_48)>(_48), std::forward<decltype(_49)>(_49), std::forward<decltype(_50)>(_50), std::forward<decltype(_51)>(_51), std::forward<decltype(_52)>(_52), std::forward<decltype(_53)>(_53), std::forward<decltype(_54)>(_54), std::forward<decltype(_55)>(_55), std::forward<decltype(_56)>(_56), std::forward<decltype(_57)>(_57), std::forward<decltype(_58)>(_58), std::forward<decltype(_59)>(_59), std::forward<decltype(_60)>(_60), std::forward<decltype(_61)>(_61), std::forward<decltype(_62)>(_62));
}

template <class Fn, class T>
  requires requires { std::remove_cvref_t<T>{any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}}; }
[[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, tag<63>) noexcept {
  auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50, _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63] = std::forward<T>(t);
  return std::forward<Fn>(fn)(std::forward<decltype(_1)>(_1), std::forward<decltype(_2)>(_2), std::forward<decltype(_3)>(_3), std::forward<decltype(_4)>(_4), std::forward<decltype(_5)>(_5), std::forward<decltype(_6)>(_6), std::forward<decltype(_7)>(_7), std::forward<decltype(_8)>(_8), std::forward<decltype(_9)>(_9), std::forward<decltype(_10)>(_10), std::forward<decltype(_11)>(_11), std::forward<decltype(_12)>(_12), std::forward<decltype(_13)>(_13), std::forward<decltype(_14)>(_14), std::forward<decltype(_15)>(_15), std::forward<decltype(_16)>(_16), std::forward<decltype(_17)>(_17), std::forward<decltype(_18)>(_18), std::forward<decltype(_19)>(_19), std::forward<decltype(_20)>(_20), std::forward<decltype(_21)>(_21), std::forward<decltype(_22)>(_22), std::forward<decltype(_23)>(_23), std::forward<decltype(_24)>(_24), std::forward<decltype(_25)>(_25), std::forward<decltype(_26)>(_26), std::forward<decltype(_27)>(_27), std::forward<decltype(_28)>(_28), std::forward<decltype(_29)>(_29), std::forward<decltype(_30)>(_30), std::forward<decltype(_31)>(_31), std::forward<decltype(_32)>(_32), std::forward<decltype(_33)>(_33), std::forward<decltype(_34)>(_34), std::forward<decltype(_35)>(_35), std::forward<decltype(_36)>(_36), std::forward<decltype(_37)>(_37), std::forward<decltype(_38)>(_38), std::forward<decltype(_39)>(_39), std::forward<decltype(_40)>(_40), std::forward<decltype(_41)>(_41), std::forward<decltype(_42)>(_42), std::forward<decltype(_43)>(_43), std::forward<decltype(_44)>(_44), std::forward<decltype(_45)>(_45), std::forward<decltype(_46)>(_46), std::forward<decltype(_47)>(_47), std::forward<decltype(_48)>(_48), std::forward<decltype(_49)>(_49), std::forward<decltype(_50)>(_50), std::forward<decltype(_51)>(_51), std::forward<decltype(_52)>(_52), std::forward<decltype(_53)>(_53), std::forward<decltype(_54)>(_54), std::forward<decltype(_55)>(_55), std::forward<decltype(_56)>(_56), std::forward<decltype(_57)>(_57), std::forward<decltype(_58)>(_58), std::forward<decltype(_59)>(_59), std::forward<decltype(_60)>(_60), std::forward<decltype(_61)>(_61), std::forward<decltype(_62)>(_62), std::forward<decltype(_63)>(_63));
}

template <class Fn, class T>
  requires requires { std::remove_cvref_t<T>{any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}, any{}}; }
[[nodiscard]] constexpr decltype(auto) visit(Fn&& fn, T&& t, tag<64>) noexcept {
  auto&& [_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50, _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64] = std::forward<T>(t);
  return std::forward<Fn>(fn)(std::forward<decltype(_1)>(_1), std::forward<decltype(_2)>(_2), std::forward<decltype(_3)>(_3), std::forward<decltype(_4)>(_4), std::forward<decltype(_5)>(_5), std::forward<decltype(_6)>(_6), std::forward<decltype(_7)>(_7), std::forward<decltype(_8)>(_8), std::forward<decltype(_9)>(_9), std::forward<decltype(_10)>(_10), std::forward<decltype(_11)>(_11), std::forward<decltype(_12)>(_12), std::forward<decltype(_13)>(_13), std::forward<decltype(_14)>(_14), std::forward<decltype(_15)>(_15), std::forward<decltype(_16)>(_16), std::forward<decltype(_17)>(_17), std::forward<decltype(_18)>(_18), std::forward<decltype(_19)>(_19), std::forward<decltype(_20)>(_20), std::forward<decltype(_21)>(_21), std::forward<decltype(_22)>(_22), std::forward<decltype(_23)>(_23), std::forward<decltype(_24)>(_24), std::forward<decltype(_25)>(_25), std::forward<decltype(_26)>(_26), std::forward<decltype(_27)>(_27), std::forward<decltype(_28)>(_28), std::forward<decltype(_29)>(_29), std::forward<decltype(_30)>(_30), std::forward<decltype(_31)>(_31), std::forward<decltype(_32)>(_32), std::forward<decltype(_33)>(_33), std::forward<decltype(_34)>(_34), std::forward<decltype(_35)>(_35), std::forward<decltype(_36)>(_36), std::forward<decltype(_37)>(_37), std::forward<decltype(_38)>(_38), std::forward<decltype(_39)>(_39), std::forward<decltype(_40)>(_40), std::forward<decltype(_41)>(_41), std::forward<decltype(_42)>(_42), std::forward<decltype(_43)>(_43), std::forward<decltype(_44)>(_44), std::forward<decltype(_45)>(_45), std::forward<decltype(_46)>(_46), std::forward<decltype(_47)>(_47), std::forward<decltype(_48)>(_48), std::forward<decltype(_49)>(_49), std::forward<decltype(_50)>(_50), std::forward<decltype(_51)>(_51), std::forward<decltype(_52)>(_52), std::forward<decltype(_53)>(_53), std::forward<decltype(_54)>(_54), std::forward<decltype(_55)>(_55), std::forward<decltype(_56)>(_56), std::forward<decltype(_57)>(_57), std::forward<decltype(_58)>(_58), std::forward<decltype(_59)>(_59), std::forward<decltype(_60)>(_60), std::forward<decltype(_61)>(_61), std::forward<decltype(_62)>(_62), std::forward<decltype(_63)>(_63), std::forward<decltype(_64)>(_64));
}
}  // namespace detail

consteval auto debug(auto&&...) -> void; // [debug facility] shows types at compile time

template <class T, std::size_t Size>
struct fixed_string {
  constexpr explicit(false) fixed_string(const T* str) { std::copy_n(str, Size, std::data(data)); }
  constexpr explicit(true) fixed_string(const auto... cs) requires (Size == sizeof...(cs)): data{cs...} { }
  [[nodiscard]] constexpr auto operator<=>(const fixed_string&) const = default;
  [[nodiscard]] constexpr explicit(false) operator std::string_view() const { return {std::data(data), Size}; }
  [[nodiscard]] constexpr auto size() const { return Size; }
  std::array<T, Size> data{};
};
template <class T, std::size_t Size> fixed_string(const T (&str)[Size]) -> fixed_string<T, Size-1>;
template<class... Cs> fixed_string(const Cs... cs) -> fixed_string<std::common_type_t<Cs...>, sizeof...(Cs)>;

static_assert(0u == std::size(fixed_string{""}));
static_assert(fixed_string{""} == fixed_string{""});
static_assert(std::string_view{""} == std::string_view{fixed_string{""}});
static_assert(3u == std::size(fixed_string{"foo"}));
static_assert(std::string_view{"foo"} == std::string_view{fixed_string{"foo"}});
static_assert(fixed_string{"foo"} == fixed_string{"foo"});

template <class Fn, class T>
[[nodiscard]] constexpr auto visit(Fn&& fn, T&& t) noexcept -> decltype(detail::visit(std::forward<Fn>(fn), std::forward<T>(t), detail::tag<REFLECT_MAX_SIZE>{})) {
  /// #if __has_builtin(__cpp_structure_bindings_can_introduce_a_pack)
  /// auto&& [... ts] = std::forward<T>(t);
  /// return std::forward<Fn>(fn)(std::forward<decltype(ts)>(ts)...);
  /// #endif
  return detail::visit(std::forward<Fn>(fn), std::forward<T>(t), detail::tag<REFLECT_MAX_SIZE>{});
}

static_assert(([] {
  struct empty {};
  static_assert(0 == visit([](auto&&... args) { return sizeof...(args); }, empty{}));

  struct one { int a; };
  static_assert(1 == visit([](auto&&... args) { return sizeof...(args); }, one{}));

  struct two { int a; int b; };
  static_assert(2 == visit([](auto&&... args) { return sizeof...(args); }, two{}));
}(), true));

template<class T>
inline constexpr auto size = visit([](auto&&... args) { return sizeof...(args); }, detail::ext<T>);

static_assert(([] {
  struct empty {};
  static_assert(0 == size<empty>);

  struct one { int a; };
  static_assert(1 == size<one>);

  struct two { int a; int b; };
  static_assert(2 == size<two>);
}(), true));

template <class T>
[[nodiscard]] consteval auto type_name(const T& = {}) noexcept {
  constexpr std::string_view name = detail::function_name<T>();
  constexpr std::string_view type_name = name.substr(detail::type_name_info::begin, name.find(detail::type_name_info::end) - detail::type_name_info::begin);
  constexpr std::string_view function_name = type_name.substr(type_name.find_last_of("::")+1);
  return [&]<auto... Ns>(std::index_sequence<Ns...>) {
    return fixed_string{function_name[Ns]...};
  }(std::make_index_sequence<std::size(function_name)>{});
}

static_assert(([] {
  struct empty {};
  struct foo {};
  struct bar {};
  static_assert(std::string_view{"empty"} == type_name<empty>());
  static_assert(std::string_view{"empty"} == type_name(empty{}));
  static_assert(std::string_view{"foo"} == type_name<foo>());
  static_assert(std::string_view{"foo"} == type_name(foo{}));
  static_assert(std::string_view{"bar"} == type_name<bar>());
  static_assert(std::string_view{"bar"} == type_name(bar{}));
}(), true));

template <std::size_t Min = REFLECT_ENUM_MIN, std::size_t Max = REFLECT_ENUM_MAX, class E>
  requires (std::is_enum_v<E> and Max > Min)
[[nodiscard]] constexpr auto enum_name(const E e = {}) noexcept {
  std::array<std::string_view, Max-Min+1> enum_names{};
  [&]<auto... Ns>(std::index_sequence<Ns...>) {
      ([&]{
        constexpr std::string_view name = detail::function_name<static_cast<E>(Ns+Min)>();
        constexpr std::string_view tmp_name = name.substr(0, name.find(detail::enum_name_info::end));
        constexpr std::string_view enum_name = tmp_name.substr(tmp_name.find_last_of(detail::enum_name_info::begin)+1);
        enum_names[Ns] = enum_name.substr(enum_name.find_last_of("::")+1);
      }(), ...);
  }(std::make_index_sequence<std::size(enum_names)>{});
  return enum_names[static_cast<decltype(Max-Min)>(e)-Min];
}

static_assert(([] {
    enum class foobar {
      foo = 1, bar = 2
    };

    enum mask : unsigned char {
      a = 0b00,
      b = 0b01,
      c = 0b10,
    };

    enum sparse {
      _42 = 42,
      _256 = 256,
    };

    static_assert([](const auto e) { return requires { enum_name(e); }; }(foobar::foo));
    static_assert([](const auto e) { return requires { enum_name(e); }; }(mask::a));
    static_assert(not [](const auto e) { return requires { enum_name(e); }; }(0));
    static_assert(not [](const auto e) { return requires { enum_name(e); }; }(42u));

    static_assert(std::string_view{"foo"} == enum_name(foobar::foo));
    static_assert(std::string_view{"bar"} == enum_name(foobar::bar));

    static_assert(std::string_view{"a"} == enum_name(mask::a));
    static_assert(std::string_view{"b"} == enum_name(mask::b));
    static_assert(std::string_view{"c"} == enum_name(mask::c));

    static_assert(std::string_view{"_42"} == enum_name<42, 256>(sparse::_42));
    static_assert(std::string_view{"_256"} == enum_name<42, 256>(sparse::_256));

    const auto e = foobar::foo;
    static_assert(std::string_view{"foo"} == enum_name(e));
}(), true));

template <std::size_t N, class T> requires (N < size<T>)
[[nodiscard]] consteval auto member_name(const T& = {}) noexcept {
  constexpr std::string_view name = detail::function_name<visit([](auto&&... args) { return detail::ptr{&detail::nth_pack_element<N>(std::forward<decltype(args)>(args)...)}; }, detail::ext<T>)>();
  constexpr std::string_view tmp = name.substr(0, name.find(detail::member_name_info::end));
  constexpr std::string_view function_name = tmp.substr(tmp.find_last_of(detail::member_name_info::begin)+1);
  return [&]<auto... Ns>(std::index_sequence<Ns...>) {
    return fixed_string{function_name[Ns]...};
  }(std::make_index_sequence<std::size(function_name)>{});
}

static_assert(([] {
  struct foo { int i; bool b; void* bar{}; };

  static_assert(std::string_view{"i"} == member_name<0, foo>());
  static_assert(std::string_view{"i"} == member_name<0>(foo{}));

  static_assert(std::string_view{"b"} == member_name<1, foo>());
  static_assert(std::string_view{"b"} == member_name<1>(foo{}));

  static_assert(std::string_view{"bar"} == member_name<2, foo>());
  static_assert(std::string_view{"bar"} == member_name<2>(foo{}));
}(), true));

template<std::size_t N, class T> requires (N < size<std::remove_cvref_t<T>>)
[[nodiscard]] constexpr decltype(auto) get(T&& t) noexcept {
  return visit([](auto&&... args) -> decltype(auto) { return detail::nth_pack_element<N>(std::forward<decltype(args)>(args)...); }, std::forward<T>(t));
}

static_assert(([] {
  struct foo { int i; bool b; };

  constexpr auto f = foo{.i=42, .b=true};

  static_assert([]<auto N> { return requires { get<N>(f); }; }.template operator()<0>());
  static_assert([]<auto N> { return requires { get<N>(f); }; }.template operator()<1>());
  static_assert(not []<auto N> { return requires { get<N>(f); }; }.template operator()<2>());

  static_assert(42 == get<0>(f));
  static_assert(true == get<1>(f));
}(), true));

template <class T, fixed_string Name>
concept has_member_name = []<auto... Ns>(std::index_sequence<Ns...>) {
  return ((std::string_view{Name} == std::string_view{member_name<Ns, std::remove_cvref_t<T>>()}) or ...);
}(std::make_index_sequence<size<std::remove_cvref_t<T>>>{});

static_assert(([] {
  struct foo { int bar; };
  static_assert(has_member_name<foo, "bar">);
  static_assert(not has_member_name<foo, "baz">);
  static_assert(not has_member_name<foo, "BAR">);
  static_assert(not has_member_name<foo, "">);
}(), true));

template<fixed_string Name, class T> requires has_member_name<T, Name>
constexpr decltype(auto) get(T&& t) noexcept {
  return visit([](auto&&... args) -> decltype(auto) {
    constexpr auto index = []<auto... Ns>(std::index_sequence<Ns...>){
      int i{};
      ([&] { if constexpr (std::string_view{Name} == std::string_view{member_name<Ns, std::remove_cvref_t<T>>()}) { i = Ns; } }(), ...);
      return i;
    }(std::make_index_sequence<size<std::remove_cvref_t<T>>>{});
    return detail::nth_pack_element<index>(std::forward<decltype(args)>(args)...);
  }, std::forward<T>(t));
}

static_assert(([] {
  struct foo { int i; bool b; };

  constexpr auto f = foo{.i=42, .b=true};

  static_assert([]<fixed_string Name> { return requires { get<Name>(f); }; }.template operator()<"i">());
  static_assert([]<fixed_string Name> { return requires { get<Name>(f); }; }.template operator()<"b">());
  static_assert(not []<fixed_string Name> { return requires { get<Name>(f); }; }.template operator()<"unknown">());

  static_assert(42 == get<"i">(f));
  static_assert(true == get<"b">(f));
}(), true));

template<template<class...> class R, class T>
[[nodiscard]] constexpr auto to(T&& t) noexcept {
   if constexpr (std::is_lvalue_reference_v<decltype(t)>) {
    return visit([](auto&&... args) { return R<decltype(std::forward<decltype(args)>(args))...>{std::forward<decltype(args)>(args)...}; }, t);
  } else {
    return visit([](auto&&... args) { return R{std::forward<decltype(args)>(args)...}; }, t);
  }
}

static_assert(([]<auto expect = [](const bool cond) { return std::array{true}[not cond]; }> {
  struct foo { int a; int b; };

  [] {
    constexpr auto t = to<std::tuple>(foo{.a=4, .b=2});
    static_assert(4 == std::get<0>(t));
    static_assert(2 == std::get<1>(t));
  }();

  [] {
    auto f = foo{.a=4, .b=2};
    auto t = to<std::tuple>(f);
    std::get<0>(t) *= 10;
    f.b=42;
    expect(40 == std::get<0>(t) and 40 == f.a);
    expect(42 == std::get<1>(t) and 42 == f.b);
  }();

  [] {
    const auto f = foo{.a=4, .b=2};
    auto t = to<std::tuple>(f);
    expect(f.a == std::get<0>(t));
    expect(f.b == std::get<1>(t));
  }();
}(), true));

template<class R, class T>
[[nodiscard]] constexpr auto to(T&& t) noexcept {
  R r{};
  auto r_view = to<std::tuple>(r);
  [&]<auto... Ns>(std::index_sequence<Ns...>) {
    ([&] {
      if constexpr (requires { get<member_name<Ns, R>()>(t); }) {
        std::get<Ns>(r_view) = get<member_name<Ns, R>()>(t);
      }
    }(), ...);
  }(std::make_index_sequence<size<R>>{});
  return r;
}

static_assert(([]<auto expect = [](const bool cond) { return std::array{true}[not cond]; }> {
  struct foo {
    int a{};
    int b{};
  };

  struct bar {
    int a{};
    int b{};
  };

  [] {
    constexpr auto b = to<bar>(foo{.a=4, .b=2});
    static_assert(4 == b.a);
    static_assert(2 == b.b);
  }();

  [] {
    auto f = foo{.a=4, .b=2};
    auto b = to<bar>(f);
    f.a = 42;
    expect(42 == f.a);
    expect(4 == b.a);
    expect(2 == b.b);
  }();

  [] {
    const auto f = foo{.a=4, .b=2};
    const auto b = to<bar>(f);
    expect(4 == b.a);
    expect(2 == b.b);
  }();

  struct baz {
    int a{};
    int c{};
  };

  [] {
    auto f = foo{.a=4, .b=2};
    auto b = to<bar>(f);
    b.a = 1;
    expect(1 == b.a and 4 == f.a);
    expect(2 == b.b and 2 == f.b);
  }();

  [] {
    const auto b = to<baz>(foo{.a=4, .b=2});
    expect(4 == b.a and 0 == b.c);
  }();
}(), true));
} // namespace reflect
#endif  // REFLECT
